<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GeoTessCPP: geotess::GeoTessGreatCircle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GeoTessCPP<span id="projectnumber">&#160;2.6</span>
   </div>
   <div id="projectbrief">Software to facilitate storage and retrieval of 3D information about the Earth.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00122.html">geotess</a></li><li class="navelem"><a class="el" href="a00167.html">GeoTessGreatCircle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a00164.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">geotess::GeoTessGreatCircle Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages information about a great circle path that extends from one point to another point, both or which are located on the surface of a unit sphere.  
 <a href="a00167.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00086_source.html">GeoTessGreatCircle.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4fddc378bce9cc1a0f1c08acecbbee8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a4fddc378bce9cc1a0f1c08acecbbee8c">GeoTessGreatCircle</a> ()</td></tr>
<tr class="memdesc:a4fddc378bce9cc1a0f1c08acecbbee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes everything to NULL.  <a href="a00167.html#a4fddc378bce9cc1a0f1c08acecbbee8c">More...</a><br /></td></tr>
<tr class="separator:a4fddc378bce9cc1a0f1c08acecbbee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4428133773161bc64a8931df57c6e40b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a4428133773161bc64a8931df57c6e40b">GeoTessGreatCircle</a> (const double *firstPoint, const double &amp;distance, const double &amp;direction)</td></tr>
<tr class="memdesc:a4428133773161bc64a8931df57c6e40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor creates a great circle from firstPoint to another point located the specified distance and direction from the the first point.  <a href="a00167.html#a4428133773161bc64a8931df57c6e40b">More...</a><br /></td></tr>
<tr class="separator:a4428133773161bc64a8931df57c6e40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d941608e7e914de12f859dccc7775d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a2d941608e7e914de12f859dccc7775d5">GeoTessGreatCircle</a> (const double *firstPoint, const double *intermediatePoint, const double *lastPoint, const bool &amp;shortestPath=true)</td></tr>
<tr class="memdesc:a2d941608e7e914de12f859dccc7775d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes three unit vectors at the beginning, middle and end of the great circle path.  <a href="a00167.html#a2d941608e7e914de12f859dccc7775d5">More...</a><br /></td></tr>
<tr class="separator:a2d941608e7e914de12f859dccc7775d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8391185294470d84b0d496f643531409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a8391185294470d84b0d496f643531409">GeoTessGreatCircle</a> (const double *firstPoint, const double *lastPoint, const bool &amp;shortestPath=true)</td></tr>
<tr class="memdesc:a8391185294470d84b0d496f643531409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes just the two GeoVectors at the beginning and end of the great circle path.  <a href="a00167.html#a8391185294470d84b0d496f643531409">More...</a><br /></td></tr>
<tr class="separator:a8391185294470d84b0d496f643531409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ae890080e8266c2e3b213be5b08b8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#ae9ae890080e8266c2e3b213be5b08b8a">GeoTessGreatCircle</a> (<a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;other)</td></tr>
<tr class="memdesc:ae9ae890080e8266c2e3b213be5b08b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="a00167.html#ae9ae890080e8266c2e3b213be5b08b8a">More...</a><br /></td></tr>
<tr class="separator:ae9ae890080e8266c2e3b213be5b08b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4882d6655e2a9fefc70cfc6b94021f9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#ad4882d6655e2a9fefc70cfc6b94021f9">~GeoTessGreatCircle</a> ()</td></tr>
<tr class="separator:ad4882d6655e2a9fefc70cfc6b94021f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4022508493796039802ee6bdacec11b2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a4022508493796039802ee6bdacec11b2">getDistance</a> ()</td></tr>
<tr class="memdesc:a4022508493796039802ee6bdacec11b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the angular distance from firstPoint to lastPoint, in radians.  <a href="a00167.html#a4022508493796039802ee6bdacec11b2">More...</a><br /></td></tr>
<tr class="separator:a4022508493796039802ee6bdacec11b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8566589811bf3cf40b4e1012d94d3be9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a8566589811bf3cf40b4e1012d94d3be9">getDistance</a> (const double *position)</td></tr>
<tr class="memdesc:a8566589811bf3cf40b4e1012d94d3be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the distance in radians measured from firstPoint to specified unit vector, measured in direction from firstPoint to lastPoint.  <a href="a00167.html#a8566589811bf3cf40b4e1012d94d3be9">More...</a><br /></td></tr>
<tr class="separator:a8566589811bf3cf40b4e1012d94d3be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123e048e1f7aa3bf8d1b4932c685e8e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a123e048e1f7aa3bf8d1b4932c685e8e3">getDistanceDegrees</a> ()</td></tr>
<tr class="memdesc:a123e048e1f7aa3bf8d1b4932c685e8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the angular distance from firstPoint to lastPoint, in degrees.  <a href="a00167.html#a123e048e1f7aa3bf8d1b4932c685e8e3">More...</a><br /></td></tr>
<tr class="separator:a123e048e1f7aa3bf8d1b4932c685e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435d5d94af86cde7bb351542d916a59d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a435d5d94af86cde7bb351542d916a59d">getDistanceDegrees</a> (const double *position)</td></tr>
<tr class="memdesc:a435d5d94af86cde7bb351542d916a59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the distance in degrees measured from firstPoint to specified unit vector, measured in direction from firstPoint to lastPoint.  <a href="a00167.html#a435d5d94af86cde7bb351542d916a59d">More...</a><br /></td></tr>
<tr class="separator:a435d5d94af86cde7bb351542d916a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b38530ed99656c9c89121d6b9598b5a"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a8b38530ed99656c9c89121d6b9598b5a">getFirst</a> ()</td></tr>
<tr class="memdesc:a8b38530ed99656c9c89121d6b9598b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the first unit vector on this GreatCircle.  <a href="a00167.html#a8b38530ed99656c9c89121d6b9598b5a">More...</a><br /></td></tr>
<tr class="separator:a8b38530ed99656c9c89121d6b9598b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595258c31787d86ddaafc1c179ae4f88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a595258c31787d86ddaafc1c179ae4f88">getIntersection</a> (<a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;other, const bool &amp;inRange, double *intersection)</td></tr>
<tr class="memdesc:a595258c31787d86ddaafc1c179ae4f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the unit vector that lies at the intersection of this GreatCircle and another GreatCircle.  <a href="a00167.html#a595258c31787d86ddaafc1c179ae4f88">More...</a><br /></td></tr>
<tr class="separator:a595258c31787d86ddaafc1c179ae4f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656fa6ecd8f897c62859d9d78b6bb935"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a656fa6ecd8f897c62859d9d78b6bb935">getLast</a> ()</td></tr>
<tr class="memdesc:a656fa6ecd8f897c62859d9d78b6bb935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the last unit vector on this GreatCircle.  <a href="a00167.html#a656fa6ecd8f897c62859d9d78b6bb935">More...</a><br /></td></tr>
<tr class="separator:a656fa6ecd8f897c62859d9d78b6bb935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e38058accca03500cf39e9ea3e4d4"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#ad90e38058accca03500cf39e9ea3e4d4">getNormal</a> ()</td></tr>
<tr class="memdesc:ad90e38058accca03500cf39e9ea3e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the unit vector that is normal to the plane of this great circle (firstPoint cross lastPoint normalized to unit length).  <a href="a00167.html#ad90e38058accca03500cf39e9ea3e4d4">More...</a><br /></td></tr>
<tr class="separator:ad90e38058accca03500cf39e9ea3e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5c3d8b33a0541c99f7bdce3e28ea0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a15c5c3d8b33a0541c99f7bdce3e28ea0">getNPoints</a> (const double &amp;spacing, const bool &amp;onCenters=false)</td></tr>
<tr class="memdesc:a15c5c3d8b33a0541c99f7bdce3e28ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of points required to span this great circle with points that have spacing not to exceed specified value.  <a href="a00167.html#a15c5c3d8b33a0541c99f7bdce3e28ea0">More...</a><br /></td></tr>
<tr class="separator:a15c5c3d8b33a0541c99f7bdce3e28ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f9cd1370b3d3b7658efce61ee477d0"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a87f9cd1370b3d3b7658efce61ee477d0">getPoint</a> (const double &amp;dist)</td></tr>
<tr class="memdesc:a87f9cd1370b3d3b7658efce61ee477d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a unit vector object located on the great circle path a specified distance from firstPoint.  <a href="a00167.html#a87f9cd1370b3d3b7658efce61ee477d0">More...</a><br /></td></tr>
<tr class="separator:a87f9cd1370b3d3b7658efce61ee477d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d26040fcdb3e3c06c6dd36d53e52dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a5d26040fcdb3e3c06c6dd36d53e52dde">getPoint</a> (const double &amp;dist, double *location)</td></tr>
<tr class="memdesc:a5d26040fcdb3e3c06c6dd36d53e52dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a unit vector object located on the great circle path a specified distance from firstPoint.  <a href="a00167.html#a5d26040fcdb3e3c06c6dd36d53e52dde">More...</a><br /></td></tr>
<tr class="separator:a5d26040fcdb3e3c06c6dd36d53e52dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af301fb7575e208e3cb5f4eabfb1bb3f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#af301fb7575e208e3cb5f4eabfb1bb3f7">getPoints</a> (const double &amp;spacing, double **points, int &amp;npoints, const bool &amp;onCenters=false)</td></tr>
<tr class="memdesc:af301fb7575e208e3cb5f4eabfb1bb3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a bunch of unit vectors equally spaced along the great circle between initial and final points that define the great circle.  <a href="a00167.html#af301fb7575e208e3cb5f4eabfb1bb3f7">More...</a><br /></td></tr>
<tr class="separator:af301fb7575e208e3cb5f4eabfb1bb3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f2314cba523e44cc30d68d32ca5fc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#aaa2f2314cba523e44cc30d68d32ca5fc">getPoints</a> (double **points, const int &amp;npoints, const bool &amp;onCenters=false)</td></tr>
<tr class="memdesc:aaa2f2314cba523e44cc30d68d32ca5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a bunch of unit vectors equally spaced along the great circle between initial and final points that define the great circle.  <a href="a00167.html#aaa2f2314cba523e44cc30d68d32ca5fc">More...</a><br /></td></tr>
<tr class="separator:aaa2f2314cba523e44cc30d68d32ca5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6818fc7510bcb379fda2e21c82f55d89"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a6818fc7510bcb379fda2e21c82f55d89">getTransform</a> ()</td></tr>
<tr class="memdesc:a6818fc7510bcb379fda2e21c82f55d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the transform matrix owned by this GreatCircle.  <a href="a00167.html#a6818fc7510bcb379fda2e21c82f55d89">More...</a><br /></td></tr>
<tr class="separator:a6818fc7510bcb379fda2e21c82f55d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868fc314abafcfec11c10a645d2e26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#ad868fc314abafcfec11c10a645d2e26c">operator=</a> (<a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;other)</td></tr>
<tr class="memdesc:ad868fc314abafcfec11c10a645d2e26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal operator.  <a href="a00167.html#ad868fc314abafcfec11c10a645d2e26c">More...</a><br /></td></tr>
<tr class="separator:ad868fc314abafcfec11c10a645d2e26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47455dc88322fe0edc0d8da588f8ae17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a47455dc88322fe0edc0d8da588f8ae17">operator==</a> (const <a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;other) const</td></tr>
<tr class="memdesc:a47455dc88322fe0edc0d8da588f8ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this and other are equal.  <a href="a00167.html#a47455dc88322fe0edc0d8da588f8ae17">More...</a><br /></td></tr>
<tr class="separator:a47455dc88322fe0edc0d8da588f8ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c97f826b1de2441ecc52e98b4391a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a3c97f826b1de2441ecc52e98b4391a18">set</a> (double *firstPoint, const double &amp;distance, const double &amp;azimuth, const bool &amp;deleteWhenDone=false)</td></tr>
<tr class="memdesc:a3c97f826b1de2441ecc52e98b4391a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the components of this GreatCircle to specified values.  <a href="a00167.html#a3c97f826b1de2441ecc52e98b4391a18">More...</a><br /></td></tr>
<tr class="separator:a3c97f826b1de2441ecc52e98b4391a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e9eab92f9d91e0c67eecc3c8a02589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#af5e9eab92f9d91e0c67eecc3c8a02589">set</a> (double *firstPoint, double *intermediatePoint, double *lastPoint, const bool &amp;shortestPath=true, const bool &amp;deleteWhenDone=false)</td></tr>
<tr class="memdesc:af5e9eab92f9d91e0c67eecc3c8a02589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the components of this GreatCircle to specified values.  <a href="a00167.html#af5e9eab92f9d91e0c67eecc3c8a02589">More...</a><br /></td></tr>
<tr class="separator:af5e9eab92f9d91e0c67eecc3c8a02589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4325ab3f2b1a468db42f37448a09a626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a4325ab3f2b1a468db42f37448a09a626">set</a> (double *frstPoint, double *lstPoint, const bool &amp;shortestPath=true, const bool &amp;deleteWhenDone=false)</td></tr>
<tr class="memdesc:a4325ab3f2b1a468db42f37448a09a626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the components of this GreatCircle to specified values.  <a href="a00167.html#a4325ab3f2b1a468db42f37448a09a626">More...</a><br /></td></tr>
<tr class="separator:a4325ab3f2b1a468db42f37448a09a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed52666e08aa052848da92818f157ef6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#aed52666e08aa052848da92818f157ef6">toString</a> ()</td></tr>
<tr class="separator:aed52666e08aa052848da92818f157ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f81c099072ce2eb74b13d7bbfbb0a3"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#ab9f81c099072ce2eb74b13d7bbfbb0a3">transform</a> (const double *x)</td></tr>
<tr class="memdesc:ab9f81c099072ce2eb74b13d7bbfbb0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector x onto the plane of this GreatCircle.  <a href="a00167.html#ab9f81c099072ce2eb74b13d7bbfbb0a3">More...</a><br /></td></tr>
<tr class="separator:ab9f81c099072ce2eb74b13d7bbfbb0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf02e1b8f071634765d921e381b821f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#abf02e1b8f071634765d921e381b821f7">transform</a> (const double *x, double *v)</td></tr>
<tr class="memdesc:abf02e1b8f071634765d921e381b821f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector x onto the plane of this GreatCircle.  <a href="a00167.html#abf02e1b8f071634765d921e381b821f7">More...</a><br /></td></tr>
<tr class="separator:abf02e1b8f071634765d921e381b821f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a63ddc24e3198222dabe19c62dd475217"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html#a63ddc24e3198222dabe19c62dd475217">getNPoints</a> (const double &amp;dist, const double &amp;spacing, const bool &amp;onCenters=false)</td></tr>
<tr class="memdesc:a63ddc24e3198222dabe19c62dd475217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of points required to span specified great circle distance with points that have spacing not to exceed specified value.  <a href="a00167.html#a63ddc24e3198222dabe19c62dd475217">More...</a><br /></td></tr>
<tr class="separator:a63ddc24e3198222dabe19c62dd475217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Manages information about a great circle path that extends from one point to another point, both or which are located on the surface of a unit sphere. </p>
<p >The GreatCircle class manages the information about a great circle path that extends from one point to another point, both or which are located on the surface of a unit sphere. It supports great circles where the distance from the firstPoint to the lastPoint are 0 to 2*PI radians apart, inclusive. Either or both of the points may coincide with one of the poles of the Earth.</p>
<p >There is a method to retrieve a point that is located on the great circle at some specified distance from the first point of the great circle.</p>
<p >The method getIntersection(other, inRange) will return a point that is located at the intersection of two great circles. In general, two great circles intersect at two points, and this method returns the one that is encountered first as one moves away from the first point of the first GreatCircle. If the Boolean argument <em>inRange</em> is true, then the method will only return a point if the point falls within the range of both great circles. In other words, the point of intersection has to reside in between the first and last point of both great circles. If <em>inRange</em> is false, then that constraint is not applied.</p>
<p >GreatCircle has the ability to transform the coordinates of an input point so that it resides in the plane of the great circle. This is useful for extracting slices from a 3D model for plotting purposes. The z-coordinate of the transformed point will point out of the plane of the great circle toward the observer. The y-coordinate of the transformed point will be equal to the normalized vector sum of the first and last point of the great circle and the x-coordinate will be y cross z.</p>
<p >The key to successfully defining a great circle path is successfully determining the unit vector that is normal to the plane of the great circle (firstPoint cross lastPoint, normalized to unit length). For great circles where the distance from firstPoint to lastPoint is more than zero and less than PI radians, this is straightforward. But for great circles longer than PI radians, great circles of exactly zero, PI or 2*PI radians length, or great circles where the first point resides on one of the poles, complications arise.</p>
<p >To determine the normal to the great circle, three constructors are provided (besides the default constructor that does nothing).</p>
<p >The first constructor is the most general. It takes four arguments: firstPoint (unit vector), intermediatePoint (unit vector), lastPoint (unit vector) and shortestPath (boolean). The normal is computed as firstPoint cross lastPoint normalized to unit length. If the distance from firstPoint to lastPoint is greater than zero and less than PI radians, then the resulting normal will have finite length and will have been successfully computed. If, however, the distance from firstPoint to lastPoint is exactly 0 or PI radians, then normal will have zero length. In this case, a second attempt to compute the normal is executed by computing firstPoint cross intermediatePoint. If this is successful, the calculation proceeds. If not successful, then the normal is computed as the first of: firstPoint cross Z, firstPoint cross Y or firstPoint cross X, whichever produces a finite length normal first. Z is the north pole, Y is (0N, 90E) and X is (0N, 0E). One of these calculations is guaranteed to produce a valid normal.</p>
<p >Once the normal has been computed, then the shortestPath argument is considered. If shortestPath is true, then no further action is taken, resulting in a great circle with length less than or equal to PI radians. If shortestPath is false then the normal is negated, effectively forcing the great circle to go the long way around the globe to get from firstPoint to lastPoint. When shortestPath is false the length of the great circle will be &gt;= PI and &lt;= 2*PI. For example, when shortestPath is true, a great circle path from (10N, 0E) to (30N, 0E) will proceed in a northerly direction for a distance of 20 degrees to get from firstPoint to lastPoint. But if shortestPath is false, the great circle will proceed in a southerly direction for 340 degrees to get from firstPoint to lastPoint.</p>
<p >The second constructor is a simplification of the first, taking only 3 arguments: firstPoint (unit vector), lastPoint (unit vector) and shortestPath (boolean). It calls the first constructor with intermediatePoint set to NULL. This is useful in cases where the calling application is certain that great circles of length exactly 0 or PI radians will not happen or is willing to accept an arbitrary path if it does happens.</p>
<p >There is a third constructor that takes 3 arguments: firstPoint (unit vector), distance (radians) and azimuth (radians). The lastPoint of the great circle is computed by moving the first point the specified distance in the specified direction. This constructor can produce great circles where the distance from firstPoint to lastPoint is &gt;= 0 and &lt;= 2*PI, inclusive. It can fail, however, if firstPoint coincides with either of the poles because the notion of azimuth from a pole in undetermined.</p>
<p >Memory management: The three parameterized constructors described above make copies of all of the unit vectors that are passed to them and delete the memory allocated for the copies when they are no longer needed. The calling application retains ownership of the variables passed to the constructors. There is an alternative strategy implemented by using the default GreatCircle constructor and then calling one of the 3 <a class="el" href="a00167.html#af5e9eab92f9d91e0c67eecc3c8a02589" title="Set the components of this GreatCircle to specified values.">set()</a> methods. The arguments of the set methods are the same as for the constructors, with one addition, and the calculation of the great circle parameters is identical. The difference is that the input unit vectors are not copied into internal variables but rather the input pointers are used directly by the GreatCircle object. Modification of these variables by the caller will have undesirable consequences for the GreatCircle object. The extra argument passed to the <a class="el" href="a00167.html#af5e9eab92f9d91e0c67eecc3c8a02589" title="Set the components of this GreatCircle to specified values.">set()</a> methods is deleteWhenDone (boolean). If true, then GreatCircle will delete the memory allocated for the unit vectors when it is done with them, otherwise it will not delete the memory and it is the responsibility of the caller to delete the memory after the lifetime of the GreatCircle object has expired. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4882d6655e2a9fefc70cfc6b94021f9" name="ad4882d6655e2a9fefc70cfc6b94021f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4882d6655e2a9fefc70cfc6b94021f9">&#9670;&nbsp;</a></span>~GeoTessGreatCircle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geotess::GeoTessGreatCircle::~GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fddc378bce9cc1a0f1c08acecbbee8c" name="a4fddc378bce9cc1a0f1c08acecbbee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fddc378bce9cc1a0f1c08acecbbee8c">&#9670;&nbsp;</a></span>GeoTessGreatCircle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessGreatCircle::GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor initializes everything to NULL. </p>

</div>
</div>
<a id="a4428133773161bc64a8931df57c6e40b" name="a4428133773161bc64a8931df57c6e40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4428133773161bc64a8931df57c6e40b">&#9670;&nbsp;</a></span>GeoTessGreatCircle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessGreatCircle::GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor creates a great circle from firstPoint to another point located the specified distance and direction from the the first point. </p>
<p >GreatCircle makes a copy of first point for internal use. The copy is deleted in the destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstPoint</td><td>unit vector. </td></tr>
    <tr><td class="paramname">distance</td><td>epicentral angular distance to lastPoint, in radians </td></tr>
    <tr><td class="paramname">direction</td><td>double direction to lastPoint, in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if firstPoint is on one of the poles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d941608e7e914de12f859dccc7775d5" name="a2d941608e7e914de12f859dccc7775d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d941608e7e914de12f859dccc7775d5">&#9670;&nbsp;</a></span>GeoTessGreatCircle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessGreatCircle::GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>intermediatePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>lastPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>shortestPath</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes three unit vectors at the beginning, middle and end of the great circle path. </p>
<p >Will not fail even when building GreatCircles that are 0, PI or 2PI radians long.</p>
<p >The key is to successfully compute a valid unit vector that is normal to the plane of the GreatCircle even when the firstPoint and lastPoint are 0 or PI radians apart. The following calculations are performed until normal is successfully computed, i.e., it has unit length. </p><ul>
<li>
normal = firstPoint X lastPoint, normalized to unit length </li>
<li>
intermediatePoint != null and normal = firstPoint X intermediatePoint, normalized to unit length. </li>
<li>
normal = firstPoint X [0., 0., 1.] </li>
<li>
normal = firstPoint X [0., 1., 0.] </li>
<li>
normal = firstPoint X [1., 0., 0.] </li>
</ul>
<p>GreatCircle makes copies of the 3 unit vectors for internal use. The copies are deleted when they are no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstPoint</td><td>unit vector of the origin of the great circle path. </td></tr>
    <tr><td class="paramname">intermediatePoint</td><td>unit vector of an intermediate point on the great circle path. If null, code will try the three cardinal directions (x, y, z). </td></tr>
    <tr><td class="paramname">lastPoint</td><td>unit vector the end of the great circle path. </td></tr>
    <tr><td class="paramname">shortestPath</td><td>if false, normal will be negated and distance from first to last will be &gt;= PI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8391185294470d84b0d496f643531409" name="a8391185294470d84b0d496f643531409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8391185294470d84b0d496f643531409">&#9670;&nbsp;</a></span>GeoTessGreatCircle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessGreatCircle::GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>lastPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>shortestPath</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that takes just the two GeoVectors at the beginning and end of the great circle path. </p>
<p >GreatCircle stores references to these arrays; no copies are made.</p>
<p >If firstPoint and lastPoint are 0 or PI radians apart, then the GreatCirlce will pass through one of the following lat,lon pairs: (90N, 0E), (0N, 90E), or (0N, 0E).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstPoint</td><td>unit vector the origin of the great circle path. </td></tr>
    <tr><td class="paramname">lastPoint</td><td>unit vector the end of the great circle path. </td></tr>
    <tr><td class="paramname">shortestPath</td><td>if false, direction from first to last is reversed and the distance from first to last will be greater than 180 degrees. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ae890080e8266c2e3b213be5b08b8a" name="ae9ae890080e8266c2e3b213be5b08b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ae890080e8266c2e3b213be5b08b8a">&#9670;&nbsp;</a></span>GeoTessGreatCircle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessGreatCircle::GeoTessGreatCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>copy contents of other into this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4022508493796039802ee6bdacec11b2" name="a4022508493796039802ee6bdacec11b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4022508493796039802ee6bdacec11b2">&#9670;&nbsp;</a></span>getDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the angular distance from firstPoint to lastPoint, in radians. </p>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a8566589811bf3cf40b4e1012d94d3be9" name="a8566589811bf3cf40b4e1012d94d3be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8566589811bf3cf40b4e1012d94d3be9">&#9670;&nbsp;</a></span>getDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getDistance </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the distance in radians measured from firstPoint to specified unit vector, measured in direction from firstPoint to lastPoint. </p>
<p >Range is zero to 2*PI</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>an earth-centered unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">GreatCircleException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123e048e1f7aa3bf8d1b4932c685e8e3" name="a123e048e1f7aa3bf8d1b4932c685e8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e048e1f7aa3bf8d1b4932c685e8e3">&#9670;&nbsp;</a></span>getDistanceDegrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getDistanceDegrees </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the angular distance from firstPoint to lastPoint, in degrees. </p>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a435d5d94af86cde7bb351542d916a59d" name="a435d5d94af86cde7bb351542d916a59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435d5d94af86cde7bb351542d916a59d">&#9670;&nbsp;</a></span>getDistanceDegrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getDistanceDegrees </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the distance in degrees measured from firstPoint to specified unit vector, measured in direction from firstPoint to lastPoint. </p>
<p >Range is zero to 360.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>an earth-centered unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance in degrees measured from firstPoint to specified unit vector, measured in direction from firstPoint to lastPoint </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">GreatCircleException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b38530ed99656c9c89121d6b9598b5a" name="a8b38530ed99656c9c89121d6b9598b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b38530ed99656c9c89121d6b9598b5a">&#9670;&nbsp;</a></span>getFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * geotess::GeoTessGreatCircle::getFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the first unit vector on this GreatCircle. </p>
<p >Caller should not delete this array</p>
<dl class="section return"><dt>Returns</dt><dd>unit vector </dd></dl>

</div>
</div>
<a id="a595258c31787d86ddaafc1c179ae4f88" name="a595258c31787d86ddaafc1c179ae4f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595258c31787d86ddaafc1c179ae4f88">&#9670;&nbsp;</a></span>getIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geotess::GeoTessGreatCircle::getIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>inRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the unit vector that lies at the intersection of this GreatCircle and another GreatCircle. </p>
<p >There are, in general, two such intersections that are 180 degrees apart. This method returns the first one that is encountered when traveling from firstPoint in the direction of lastPoint. The other intersection can be retrieved by negating every element of the unit vector that is returned by this method.</p>
<p >If inRange is true then the point of intersection must reside between the firstPoint and the lastPoint of both this and other GreatCircles.</p>
<p >It is the responsibility of the caller to delete the array returned by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>GreatCircle </td></tr>
    <tr><td class="paramname">inRange</td><td>if true then the point of intersection must reside between the firstPoint and the lastPoint of both this and other GreatCircles. </td></tr>
    <tr><td class="paramname">intersection</td><td>unit vector. returns NaN_DOUBLE if the this GreatCircle and other GreatCircle are coincident, i.e., their normals are equal. Also returns null if inRange is true and the point of intersection does not reside between firstPoint and lastPoint of both this and other GreatCircle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a656fa6ecd8f897c62859d9d78b6bb935" name="a656fa6ecd8f897c62859d9d78b6bb935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656fa6ecd8f897c62859d9d78b6bb935">&#9670;&nbsp;</a></span>getLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * geotess::GeoTessGreatCircle::getLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the last unit vector on this GreatCircle. </p>
<p >Caller should not delete this array</p>
<dl class="section return"><dt>Returns</dt><dd>unit vector </dd></dl>

</div>
</div>
<a id="ad90e38058accca03500cf39e9ea3e4d4" name="ad90e38058accca03500cf39e9ea3e4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90e38058accca03500cf39e9ea3e4d4">&#9670;&nbsp;</a></span>getNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * geotess::GeoTessGreatCircle::getNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the unit vector that is normal to the plane of this great circle (firstPoint cross lastPoint normalized to unit length). </p>
<p >If firstPoint on left and lastPoint on right, normal points away from the observer.</p>
<p >Caller should not delete this array</p>
<dl class="section return"><dt>Returns</dt><dd>double[] </dd></dl>

</div>
</div>
<a id="a63ddc24e3198222dabe19c62dd475217" name="a63ddc24e3198222dabe19c62dd475217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ddc24e3198222dabe19c62dd475217">&#9670;&nbsp;</a></span>getNPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int geotess::GeoTessGreatCircle::getNPoints </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of points required to span specified great circle distance with points that have spacing not to exceed specified value. </p>
<p >If onCenters is true then points will reside in the centers of equal sized intervals. If onCenters is false (default), then first point coincides with start of great circle, last point coincides with end of great circle and other points are equally spaced in between. Actual spacing of points will generally be less than requested spacing so that integral number of equally spaced points will span the great circle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>length of great circle path in radians </td></tr>
    <tr><td class="paramname">spacing</td><td>maximum spacing between points in radians. </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, points in middle of intervals, other wise points at boundaries of intervals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15c5c3d8b33a0541c99f7bdce3e28ea0" name="a15c5c3d8b33a0541c99f7bdce3e28ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c5c3d8b33a0541c99f7bdce3e28ea0">&#9670;&nbsp;</a></span>getNPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int geotess::GeoTessGreatCircle::getNPoints </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of points required to span this great circle with points that have spacing not to exceed specified value. </p>
<p >If onCenters is true then points will reside in the centers of equal sized intervals. If onCenters is false (default), then first point coincides with start of great circle, last point coincides with end of great circle and other points are equally spaced in between. Actual spacing of points will generally be less than requested spacing so that integral number of equally spaced points will span the great circle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spacing</td><td>maximum spacing between points in radians. </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, points in middle of intervals, other wise points at boundaries of intervals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f9cd1370b3d3b7658efce61ee477d0" name="a87f9cd1370b3d3b7658efce61ee477d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f9cd1370b3d3b7658efce61ee477d0">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * geotess::GeoTessGreatCircle::getPoint </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a unit vector object located on the great circle path a specified distance from firstPoint. </p>
<p >It is the caller's responsibility to delete the returned array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>double the angular distance from firstPoint, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">GreatCircleException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d26040fcdb3e3c06c6dd36d53e52dde" name="a5d26040fcdb3e3c06c6dd36d53e52dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d26040fcdb3e3c06c6dd36d53e52dde">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::getPoint </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a unit vector object located on the great circle path a specified distance from firstPoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>double the angular distance from firstPoint, in radians. </td></tr>
    <tr><td class="paramname">location</td><td>(output) unit vector located on the great circle path a specified distance from firstPoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af301fb7575e208e3cb5f4eabfb1bb3f7" name="af301fb7575e208e3cb5f4eabfb1bb3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af301fb7575e208e3cb5f4eabfb1bb3f7">&#9670;&nbsp;</a></span>getPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getPoints </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a bunch of unit vectors equally spaced along the great circle between initial and final points that define the great circle. </p>
<p >Supplied array of points must be large enough to hold the necessary number of points. Caller owns the unit vectors and should delete them when done with them. This method neither creates nor deletes any memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spacing</td><td>the desired point spacing in radians. Actual spacing of points will generally be less than requested spacing so that integral number of equally spaced points will span the great circle. </td></tr>
    <tr><td class="paramname">points</td><td>an array of unit vectors that will be populated with equally spaced unit vectors along the great circle. </td></tr>
    <tr><td class="paramname">npoints</td><td>number of points along the great circle path </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, the points are located at the centers of path increments of equal size. If onCenters is false, the first point is located at the starting point of the great circle, the last point is located at the final point of the great circle and the remaining points are equally spaced in between. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual spacing between the points in radians. </dd></dl>

</div>
</div>
<a id="aaa2f2314cba523e44cc30d68d32ca5fc" name="aaa2f2314cba523e44cc30d68d32ca5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f2314cba523e44cc30d68d32ca5fc">&#9670;&nbsp;</a></span>getPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessGreatCircle::getPoints </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a bunch of unit vectors equally spaced along the great circle between initial and final points that define the great circle. </p>
<p >Supplied array of points must be large enough to hold the specified number of points. Caller owns the unit vectors and should delete them when done with them. This method neither creates nor deletes any memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>an array of unit vectors that will be populated with equally spaced unit vectors along the great circle. </td></tr>
    <tr><td class="paramname">npoints</td><td>the number of points desired. </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, the points are located at the centers of path increments of equal size. If onCenters is false, the first point is located at the starting point of the great circle, the last point is located at the final point of the great circle and the remaining points are equally spaced in between. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual spacing between the points in radians. </dd></dl>

</div>
</div>
<a id="a6818fc7510bcb379fda2e21c82f55d89" name="a6818fc7510bcb379fda2e21c82f55d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6818fc7510bcb379fda2e21c82f55d89">&#9670;&nbsp;</a></span>getTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** geotess::GeoTessGreatCircle::getTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the transform matrix owned by this GreatCircle. </p>
<p >Transform is a 3 x 3 matrix such that when a vector is multiplied by transform, the vector will be projected onto the plane of this GreatCircle. The z direction will point out of the plane of the great circle in the direction of the observer (lastPoint cross firstPoint; parallel to normal). The y direction will correspond to the mean of firstPoint and lastPoint. The x direction will correspond to y cross z, forming a right handed coordinate system.</p>
<p >Caller should not delete this array</p>
<dl class="section return"><dt>Returns</dt><dd>double** </dd></dl>

</div>
</div>
<a id="ad868fc314abafcfec11c10a645d2e26c" name="ad868fc314abafcfec11c10a645d2e26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868fc314abafcfec11c10a645d2e26c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equal operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>copy contents of other into this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47455dc88322fe0edc0d8da588f8ae17" name="a47455dc88322fe0edc0d8da588f8ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47455dc88322fe0edc0d8da588f8ae17">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geotess::GeoTessGreatCircle::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00167.html">GeoTessGreatCircle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this and other are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c97f826b1de2441ecc52e98b4391a18" name="a3c97f826b1de2441ecc52e98b4391a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c97f826b1de2441ecc52e98b4391a18">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::set </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>azimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>deleteWhenDone</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the components of this GreatCircle to specified values. </p>
<p >Memory: This method stores a reference to firstPoint, not a copy. If deleteWhenDone is true, then GreatCircle will delete this reference when it is done with it, otherwise it will not. The default is that GreatCircle will not delete the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstPoint</td><td>unit vector. </td></tr>
    <tr><td class="paramname">distance</td><td>epicentral angular distance to lastPoint, in radians </td></tr>
    <tr><td class="paramname">azimuth</td><td>double direction to lastPoint, in radians </td></tr>
    <tr><td class="paramname">deleteWhenDone</td><td>if true, references to firstPoint, intermediatePoint and lastPoint will be deleted when no longer needed, otherwise not deleted. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if firstPoint is on one of the poles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5e9eab92f9d91e0c67eecc3c8a02589" name="af5e9eab92f9d91e0c67eecc3c8a02589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e9eab92f9d91e0c67eecc3c8a02589">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::set </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>intermediatePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lastPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>shortestPath</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>deleteWhenDone</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the components of this GreatCircle to specified values. </p>
<p >The key is to successfully compute a valid unit vector that is normal to the plane of the GreatCircle even when the firstPoint and lastPoint are 0 or PI radians apart. The following calculations are performed until normal is successfully computed, i.e., it has unit length. </p><ul>
<li>
normal = firstPoint X lastPoint, normalized to unit length </li>
<li>
intermediatePoint != null and normal = firstPoint X intermediatePoint, normalized to unit length. </li>
<li>
normal = firstPoint X [0., 0., 1.] </li>
<li>
normal = firstPoint X [0., 1., 0.] </li>
<li>
normal = firstPoint X [1., 0., 0.] </li>
</ul>
<p >Memory: This method stores references to firstPoint, intermediatePoint and lastPoint, not copies. If deleteWhenDone is true, then GreatCircle will delete these references when it is done with them, otherwise it will not. The default is that GreatCircle will not delete these variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstPoint</td><td>unit vector of the origin of the great circle path. </td></tr>
    <tr><td class="paramname">intermediatePoint</td><td>unit vector of an intermediate point on the great circle path. If null, code will try the three cardinal directions (x, y, z). </td></tr>
    <tr><td class="paramname">lastPoint</td><td>unit vector the end of the great circle path. </td></tr>
    <tr><td class="paramname">shortestPath</td><td>if false, normal will be negated and distance from first to last will be &gt;= PI. Defaults to true. </td></tr>
    <tr><td class="paramname">deleteWhenDone</td><td>if true, references to firstPoint, intermediatePoint and lastPoint will be deleted when no longer needed, otherwise not deleted. Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4325ab3f2b1a468db42f37448a09a626" name="a4325ab3f2b1a468db42f37448a09a626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4325ab3f2b1a468db42f37448a09a626">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::set </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>frstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>shortestPath</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>deleteWhenDone</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the components of this GreatCircle to specified values. </p>
<p >If firstPoint and lastPoint are 0 or PI radians apart, then the GreatCirlce will pass through one of the following lat,lon pairs: (90N, 0E), (0N, 90E), or (0N, 0E).</p>
<p >Memory: This method stores references to firstPoint and lastPoint, not copies. If deleteWhenDone is true, then GreatCircle will delete these references when it is done with them, otherwise it will not. The default is that GreatCircle will not delete these variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frstPoint</td><td>unit vector of the origin of the great circle path. </td></tr>
    <tr><td class="paramname">lstPoint</td><td>unit vector the end of the great circle path. </td></tr>
    <tr><td class="paramname">shortestPath</td><td>if false, normal will be negated and distance from first to last will be &gt;= PI. Defaults to true. </td></tr>
    <tr><td class="paramname">deleteWhenDone</td><td>if true, references to firstPoint, intermediatePoint and lastPoint will be deleted when no longer needed, otherwise not deleted. Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed52666e08aa052848da92818f157ef6" name="aed52666e08aa052848da92818f157ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed52666e08aa052848da92818f157ef6">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string geotess::GeoTessGreatCircle::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9f81c099072ce2eb74b13d7bbfbb0a3" name="ab9f81c099072ce2eb74b13d7bbfbb0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f81c099072ce2eb74b13d7bbfbb0a3">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * geotess::GeoTessGreatCircle::transform </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector x onto the plane of this GreatCircle. </p>
<p >Returns a 3 element vector g such that g[2] is the component of x that points out of the plane of the GreatCircle (toward the observer). g[1] is the component of x parallel to the mean of firstPoint and lastPoint, and g[0] is the remaining part of x. For an observer viewing the great circle from the normal direction (firstPoint on the left and lastPoint on the right), g[2] will be the component of x that points toward the observer, g[1] will be 'up' and g[0] will be 'to the right'. For plotting values on a great circle 'slice' through a model, g[0] will be the x-component, g[1] will be the y-component and g[2] should be ignored.</p>
<p >Caller must delete the array returned by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double[] the 3 element array containing the vector to be projected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double[] the projection of x onto plane of this GreatCircle </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">GreatCircleException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf02e1b8f071634765d921e381b821f7" name="abf02e1b8f071634765d921e381b821f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf02e1b8f071634765d921e381b821f7">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geotess::GeoTessGreatCircle::transform </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector x onto the plane of this GreatCircle. </p>
<p >Returns a 3 element vector g such that g[2] is the component of x that points out of the plane of the GreatCircle (toward the observer). g[1] is the component of x parallel to the mean of firstPoint and lastPoint, and g[0] is the remaining part of x. For an observer viewing the great circle from the normal direction (firstPoint on the left and lastPoint on the right), g[2] will be the component of x that points toward the observer, g[1] will be 'up' and g[0] will be 'to the right'. For plotting values on a great circle 'slice' through a model, g[0] will be the x-component, g[1] will be the y-component and g[2] should be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double[] the 3 element array containing the vector to be projected. </td></tr>
    <tr><td class="paramname">v</td><td>double[] the projection of x onto plane of this GreatCircle </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">GreatCircleException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="a00086_source.html">GeoTessGreatCircle.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
