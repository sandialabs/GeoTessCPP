<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GeoTessCPP: geotess::GeoTessUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GeoTessCPP<span id="projectnumber">&#160;2.2</span>
   </div>
   <div id="projectbrief">Software to facilitate storage and retrieval of 3D information about the Earth.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00122.html">geotess</a></li><li class="navelem"><a class="el" href="a00275.html">GeoTessUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="a00272.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">geotess::GeoTessUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collection of static functions to manipulate geographic information.  
 <a href="a00275.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00095_source.html">GeoTessUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad908fd8b35ccaec215d7eae849aafadf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ad908fd8b35ccaec215d7eae849aafadf">GeoTessUtils</a> ()</td></tr>
<tr class="memdesc:ad908fd8b35ccaec215d7eae849aafadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="a00275.html#ad908fd8b35ccaec215d7eae849aafadf">More...</a><br /></td></tr>
<tr class="separator:ad908fd8b35ccaec215d7eae849aafadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9340ce3c08bc0afb853882e7f9043f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a2d9340ce3c08bc0afb853882e7f9043f">~GeoTessUtils</a> ()</td></tr>
<tr class="memdesc:a2d9340ce3c08bc0afb853882e7f9043f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="a00275.html#a2d9340ce3c08bc0afb853882e7f9043f">More...</a><br /></td></tr>
<tr class="separator:a2d9340ce3c08bc0afb853882e7f9043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae420582a046dbb4aa42edcf4ea8d2ee3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ae420582a046dbb4aa42edcf4ea8d2ee3">class_size</a> () const</td></tr>
<tr class="memdesc:ae420582a046dbb4aa42edcf4ea8d2ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class size.  <a href="a00275.html#ae420582a046dbb4aa42edcf4ea8d2ee3">More...</a><br /></td></tr>
<tr class="separator:ae420582a046dbb4aa42edcf4ea8d2ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a35c94d177a5060a57f1f7e5c77b75175"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a35c94d177a5060a57f1f7e5c77b75175">angle</a> (const double *const v0, const double *const v1)</td></tr>
<tr class="memdesc:a35c94d177a5060a57f1f7e5c77b75175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular distance in radians between two unit vectors.  <a href="a00275.html#a35c94d177a5060a57f1f7e5c77b75175">More...</a><br /></td></tr>
<tr class="separator:a35c94d177a5060a57f1f7e5c77b75175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95f9799b0190bb15c4b15bad0701cdf"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#af95f9799b0190bb15c4b15bad0701cdf">angleDegrees</a> (const double *const v0, const double *const v1)</td></tr>
<tr class="memdesc:af95f9799b0190bb15c4b15bad0701cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular distance in degrees between two unit vectors.  <a href="a00275.html#af95f9799b0190bb15c4b15bad0701cdf">More...</a><br /></td></tr>
<tr class="separator:af95f9799b0190bb15c4b15bad0701cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdab7c30b907e3833844b75df874222"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adcdab7c30b907e3833844b75df874222">azimuth</a> (const double *const v1, const double *const v2, double errorValue)</td></tr>
<tr class="memdesc:adcdab7c30b907e3833844b75df874222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the azimuth from unit vectors v1 to v2.  <a href="a00275.html#adcdab7c30b907e3833844b75df874222">More...</a><br /></td></tr>
<tr class="separator:adcdab7c30b907e3833844b75df874222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1518159e5f85502224342a1968c5a256"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a1518159e5f85502224342a1968c5a256">azimuthDegrees</a> (const double *const v1, const double *const v2, double errorValue)</td></tr>
<tr class="memdesc:a1518159e5f85502224342a1968c5a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the azimuth from unit vectors v1 to v2.  <a href="a00275.html#a1518159e5f85502224342a1968c5a256">More...</a><br /></td></tr>
<tr class="separator:a1518159e5f85502224342a1968c5a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b6b0fe4fd46cc35a6bc67acb064731"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a04b6b0fe4fd46cc35a6bc67acb064731">center</a> (double const *const *const v, int n)</td></tr>
<tr class="memdesc:a04b6b0fe4fd46cc35a6bc67acb064731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the normalized vector sum of the supplied unit vectors.  <a href="a00275.html#a04b6b0fe4fd46cc35a6bc67acb064731">More...</a><br /></td></tr>
<tr class="separator:a04b6b0fe4fd46cc35a6bc67acb064731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e969b48825320f3be11ac7128f9c950"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a1e969b48825320f3be11ac7128f9c950">center</a> (vector&lt; double * &gt; v, double *x)</td></tr>
<tr class="memdesc:a1e969b48825320f3be11ac7128f9c950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the normalized vector sum of the supplied unit vectors.  <a href="a00275.html#a1e969b48825320f3be11ac7128f9c950">More...</a><br /></td></tr>
<tr class="separator:a1e969b48825320f3be11ac7128f9c950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616dd66a2f8d3e7b9de34246a30e389f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a616dd66a2f8d3e7b9de34246a30e389f">circumCenter</a> (const double *const v0, const double *const v1, const double *const v2, double *const vs)</td></tr>
<tr class="memdesc:a616dd66a2f8d3e7b9de34246a30e389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three unit vectors, v0, v1 and v2, find the circumcenter, vs.  <a href="a00275.html#a616dd66a2f8d3e7b9de34246a30e389f">More...</a><br /></td></tr>
<tr class="separator:a616dd66a2f8d3e7b9de34246a30e389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa54a8b6796c60e7ae5134acbc9587c"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a3aa54a8b6796c60e7ae5134acbc9587c">circumCenterPlus</a> (const double *const v0, const double *const v1, const double *const v2)</td></tr>
<tr class="memdesc:a3aa54a8b6796c60e7ae5134acbc9587c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three unit vectors, v0, v1 and v2, find the circumcenter, vs.  <a href="a00275.html#a3aa54a8b6796c60e7ae5134acbc9587c">More...</a><br /></td></tr>
<tr class="separator:a3aa54a8b6796c60e7ae5134acbc9587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7cf4cfff938edba6d9387e24648a15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adf7cf4cfff938edba6d9387e24648a15">circumCenterPlus</a> (const double *const v0, const double *const v1, const double *const v2, double *const vs)</td></tr>
<tr class="memdesc:adf7cf4cfff938edba6d9387e24648a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three unit vectors, v0, v1 and v2, find the circumcenter, vs.  <a href="a00275.html#adf7cf4cfff938edba6d9387e24648a15">More...</a><br /></td></tr>
<tr class="separator:adf7cf4cfff938edba6d9387e24648a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d31573f9e82507169a5ac471941f51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a50d31573f9e82507169a5ac471941f51">circumCenterPlus</a> (double const *const *const t, double *const vs)</td></tr>
<tr class="memdesc:a50d31573f9e82507169a5ac471941f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the three unit vectors, t[0], t[1] and t[2], find the circumcenter, vs.  <a href="a00275.html#a50d31573f9e82507169a5ac471941f51">More...</a><br /></td></tr>
<tr class="separator:a50d31573f9e82507169a5ac471941f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f037c3aa3e90ef3d8c8d898c26ffa59"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a8f037c3aa3e90ef3d8c8d898c26ffa59">class_name</a> ()</td></tr>
<tr class="memdesc:a8f037c3aa3e90ef3d8c8d898c26ffa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class name.  <a href="a00275.html#a8f037c3aa3e90ef3d8c8d898c26ffa59">More...</a><br /></td></tr>
<tr class="separator:a8f037c3aa3e90ef3d8c8d898c26ffa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bfef7508a6350c1e3bbb442133f5eb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a26bfef7508a6350c1e3bbb442133f5eb">cross</a> (const double *const v1, const double *const v2, double *const rslt)</td></tr>
<tr class="memdesc:a26bfef7508a6350c1e3bbb442133f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two 3-component vectors.  <a href="a00275.html#a26bfef7508a6350c1e3bbb442133f5eb">More...</a><br /></td></tr>
<tr class="separator:a26bfef7508a6350c1e3bbb442133f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3195758779fd3646fec23dbec3748c"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a1f3195758779fd3646fec23dbec3748c">crossNormal</a> (const double *const u, const double *const v)</td></tr>
<tr class="memdesc:a1f3195758779fd3646fec23dbec3748c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized cross product of two 3-component unit vectors.  <a href="a00275.html#a1f3195758779fd3646fec23dbec3748c">More...</a><br /></td></tr>
<tr class="separator:a1f3195758779fd3646fec23dbec3748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af959a66c281a40f1baa9620504b193"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a4af959a66c281a40f1baa9620504b193">crossNormal</a> (const double *const u, const double *const v, double *const w)</td></tr>
<tr class="memdesc:a4af959a66c281a40f1baa9620504b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized cross product of two 3-component unit vectors.  <a href="a00275.html#a4af959a66c281a40f1baa9620504b193">More...</a><br /></td></tr>
<tr class="separator:a4af959a66c281a40f1baa9620504b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808084382483e6d54663e37aa5ea706d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a808084382483e6d54663e37aa5ea706d">crossNorth</a> (const double *const u, double *const w)</td></tr>
<tr class="memdesc:a808084382483e6d54663e37aa5ea706d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized cross product of a 3-component unit vector with the north pole.  <a href="a00275.html#a808084382483e6d54663e37aa5ea706d">More...</a><br /></td></tr>
<tr class="separator:a808084382483e6d54663e37aa5ea706d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3869e0326dd5b1036c90049403160dcb"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a3869e0326dd5b1036c90049403160dcb">dot</a> (const double *const v0, const double *const v1)</td></tr>
<tr class="memdesc:a3869e0326dd5b1036c90049403160dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dot product of two vectors.  <a href="a00275.html#a3869e0326dd5b1036c90049403160dcb">More...</a><br /></td></tr>
<tr class="separator:a3869e0326dd5b1036c90049403160dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c1291eee7a438280e8d4b190c4f81"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a063c1291eee7a438280e8d4b190c4f81">eulerRotation</a> (const double *const u, double **euler)</td></tr>
<tr class="memdesc:a063c1291eee7a438280e8d4b190c4f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an Euler rotation matrix computed from 3 Euler rotation angles using method <a class="el" href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc" title="Given three Euler angles in radians, retrieve the Euler rotation matrix.">getEulerMatrix()</a>, apply the rotation to 3-component unit vector u and return the result in a new 3-component unit vector.  <a href="a00275.html#a063c1291eee7a438280e8d4b190c4f81">More...</a><br /></td></tr>
<tr class="separator:a063c1291eee7a438280e8d4b190c4f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4299f19fc8acef0fbb02353f232d657"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#af4299f19fc8acef0fbb02353f232d657">eulerRotation</a> (const double *const u, double **euler, double *v)</td></tr>
<tr class="memdesc:af4299f19fc8acef0fbb02353f232d657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an Euler rotation matrix computed from 3 Euler rotation angles using method <a class="el" href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc" title="Given three Euler angles in radians, retrieve the Euler rotation matrix.">getEulerMatrix()</a>, apply the rotation to 3-component unit vector u and return the result in unit vector v.  <a href="a00275.html#af4299f19fc8acef0fbb02353f232d657">More...</a><br /></td></tr>
<tr class="separator:af4299f19fc8acef0fbb02353f232d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5747bfd26b78e8ce835d24c1699d847"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ac5747bfd26b78e8ce835d24c1699d847">getDistance3D</a> (const double *const v0, double r0, const double *const v1, double r1)</td></tr>
<tr class="memdesc:ac5747bfd26b78e8ce835d24c1699d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two unit vectors and their radii, return the straight line separation between their tips.  <a href="a00275.html#ac5747bfd26b78e8ce835d24c1699d847">More...</a><br /></td></tr>
<tr class="separator:ac5747bfd26b78e8ce835d24c1699d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8506836f063f685d9884415e22f3ab7b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a8506836f063f685d9884415e22f3ab7b">getEarthRadius</a> (const double *const v)</td></tr>
<tr class="memdesc:a8506836f063f685d9884415e22f3ab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the radius of the Earth in km at the position specified by an Earth-centered unit vector.  <a href="a00275.html#a8506836f063f685d9884415e22f3ab7b">More...</a><br /></td></tr>
<tr class="separator:a8506836f063f685d9884415e22f3ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48be48b8f6d0c6140a4b673bef1374cc"><td class="memItemLeft" align="right" valign="top">static double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc">getEulerMatrix</a> (const double *const a)</td></tr>
<tr class="memdesc:a48be48b8f6d0c6140a4b673bef1374cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three Euler angles in radians, retrieve the Euler rotation matrix.  <a href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc">More...</a><br /></td></tr>
<tr class="separator:a48be48b8f6d0c6140a4b673bef1374cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd1dd386e185bfd21afbb117a4875c"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a25bd1dd386e185bfd21afbb117a4875c">getEulerRotationAngles</a> (const double *const u)</td></tr>
<tr class="memdesc:a25bd1dd386e185bfd21afbb117a4875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a location, retrieve the Euler rotation angles, in radians, that will rotate the north pole ([0., 0., 1.  <a href="a00275.html#a25bd1dd386e185bfd21afbb117a4875c">More...</a><br /></td></tr>
<tr class="separator:a25bd1dd386e185bfd21afbb117a4875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd3a9cbe00c33e01f4809548ecfc79e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a1fd3a9cbe00c33e01f4809548ecfc79e">getGeocentricLat</a> (const double &amp;lat)</td></tr>
<tr class="memdesc:a1fd3a9cbe00c33e01f4809548ecfc79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return geocentric latitude given a geographic latitude using the WGS84 ellipsoid.  <a href="a00275.html#a1fd3a9cbe00c33e01f4809548ecfc79e">More...</a><br /></td></tr>
<tr class="separator:a1fd3a9cbe00c33e01f4809548ecfc79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6f3dd7e5ef8a712f6ccae14282496"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a66f6f3dd7e5ef8a712f6ccae14282496">getGeographicLat</a> (const double &amp;lat)</td></tr>
<tr class="memdesc:a66f6f3dd7e5ef8a712f6ccae14282496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return geographic latitude given a geocentric latitude using the WGS84 ellipsoid.  <a href="a00275.html#a66f6f3dd7e5ef8a712f6ccae14282496">More...</a><br /></td></tr>
<tr class="separator:a66f6f3dd7e5ef8a712f6ccae14282496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa54c50cf12cba7cbcbfa784e2aaf1d"><td class="memItemLeft" align="right" valign="top">static double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#abaa54c50cf12cba7cbcbfa784e2aaf1d">getGreatCircle</a> (const double *const v, double <a class="el" href="a00275.html#adcdab7c30b907e3833844b75df874222">azimuth</a>)</td></tr>
<tr class="memdesc:abaa54c50cf12cba7cbcbfa784e2aaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#abaa54c50cf12cba7cbcbfa784e2aaf1d">More...</a><br /></td></tr>
<tr class="separator:abaa54c50cf12cba7cbcbfa784e2aaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2242d24108f33e4a9c4453771236938a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a2242d24108f33e4a9c4453771236938a">getGreatCircle</a> (const double *const v, double <a class="el" href="a00275.html#adcdab7c30b907e3833844b75df874222">azimuth</a>, double **const gc)</td></tr>
<tr class="memdesc:a2242d24108f33e4a9c4453771236938a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#a2242d24108f33e4a9c4453771236938a">More...</a><br /></td></tr>
<tr class="separator:a2242d24108f33e4a9c4453771236938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99db79c6ce26361a3a1d3a07efcf214"><td class="memItemLeft" align="right" valign="top">static double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ab99db79c6ce26361a3a1d3a07efcf214">getGreatCircle</a> (const double *const v0, const double *const v1)</td></tr>
<tr class="memdesc:ab99db79c6ce26361a3a1d3a07efcf214"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#ab99db79c6ce26361a3a1d3a07efcf214">More...</a><br /></td></tr>
<tr class="separator:ab99db79c6ce26361a3a1d3a07efcf214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9763a021b66125eec799f99c47ba7306"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a9763a021b66125eec799f99c47ba7306">getGreatCircle</a> (const double *const v0, const double *const v1, double **const gc)</td></tr>
<tr class="memdesc:a9763a021b66125eec799f99c47ba7306"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#a9763a021b66125eec799f99c47ba7306">More...</a><br /></td></tr>
<tr class="separator:a9763a021b66125eec799f99c47ba7306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13695d9fff836c8ac16b4c5b6567688a"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a">getGreatCirclePoint</a> (double const *const *const greatCircle, double distance)</td></tr>
<tr class="memdesc:a13695d9fff836c8ac16b4c5b6567688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a">More...</a><br /></td></tr>
<tr class="separator:a13695d9fff836c8ac16b4c5b6567688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f167c1ca0bb27227a6c7a93490a90e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a11f167c1ca0bb27227a6c7a93490a90e">getGreatCirclePoint</a> (double const *const *const greatCircle, double distance, double *const v)</td></tr>
<tr class="memdesc:a11f167c1ca0bb27227a6c7a93490a90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A great circle is defined by two unit vectors that are 90 degrees apart.  <a href="a00275.html#a11f167c1ca0bb27227a6c7a93490a90e">More...</a><br /></td></tr>
<tr class="separator:a11f167c1ca0bb27227a6c7a93490a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb34aec60ddf70ea9b8d73699a37a30"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a5fb34aec60ddf70ea9b8d73699a37a30">getGreatCirclePoints</a> (double *ptA, double *ptB, const double &amp;delta, const bool &amp;onCenters)</td></tr>
<tr class="memdesc:a5fb34aec60ddf70ea9b8d73699a37a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of points that would be required to populate a great circle path from point A to point B with equally spaced points given that the spacing can be no greater than delta.  <a href="a00275.html#a5fb34aec60ddf70ea9b8d73699a37a30">More...</a><br /></td></tr>
<tr class="separator:a5fb34aec60ddf70ea9b8d73699a37a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8800373d5ccd2d2f004ce27545f04b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a2b8800373d5ccd2d2f004ce27545f04b">getGreatCirclePoints</a> (double *ptA, double *ptB, const double &amp;delta, const bool &amp;onCenters, double **points, int &amp;npoints)</td></tr>
<tr class="memdesc:a2b8800373d5ccd2d2f004ce27545f04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the unit vectors of a bunch of points distributed along a great circle path between two points.  <a href="a00275.html#a2b8800373d5ccd2d2f004ce27545f04b">More...</a><br /></td></tr>
<tr class="separator:a2b8800373d5ccd2d2f004ce27545f04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab761184340d27dc1d5c8974bb654204b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ab761184340d27dc1d5c8974bb654204b">getGreatCirclePoints</a> (double *ptA, double *ptB, const int &amp;npoints, const bool &amp;onCenters, double **points)</td></tr>
<tr class="memdesc:ab761184340d27dc1d5c8974bb654204b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the unit vectors of a bunch of points distributed along a great circle path between two points.  <a href="a00275.html#ab761184340d27dc1d5c8974bb654204b">More...</a><br /></td></tr>
<tr class="separator:ab761184340d27dc1d5c8974bb654204b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e89df0590bf5c1d75bf947bf8b3fae6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a0e89df0590bf5c1d75bf947bf8b3fae6">getLat</a> (const double *const v)</td></tr>
<tr class="memdesc:a0e89df0590bf5c1d75bf947bf8b3fae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 3-component unit vector to geographic latitude, in radians.  <a href="a00275.html#a0e89df0590bf5c1d75bf947bf8b3fae6">More...</a><br /></td></tr>
<tr class="separator:a0e89df0590bf5c1d75bf947bf8b3fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03715e35fdbdc69885c3494eaa32ace"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ad03715e35fdbdc69885c3494eaa32ace">getLatDegrees</a> (const double *const v)</td></tr>
<tr class="memdesc:ad03715e35fdbdc69885c3494eaa32ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 3-component unit vector to geographic latitude, in degrees.  <a href="a00275.html#ad03715e35fdbdc69885c3494eaa32ace">More...</a><br /></td></tr>
<tr class="separator:ad03715e35fdbdc69885c3494eaa32ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa096dd35c28a97ecf2a353d03daace6b"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#aa096dd35c28a97ecf2a353d03daace6b">getLatLonString</a> (const double *const v)</td></tr>
<tr class="separator:aa096dd35c28a97ecf2a353d03daace6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9626244c7506dd83498e70a2dace07"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#aab9626244c7506dd83498e70a2dace07">getLon</a> (const double *const v)</td></tr>
<tr class="memdesc:aab9626244c7506dd83498e70a2dace07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 3-component unit vector to a longitude, in radians.  <a href="a00275.html#aab9626244c7506dd83498e70a2dace07">More...</a><br /></td></tr>
<tr class="separator:aab9626244c7506dd83498e70a2dace07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7aab052f8d501f408313863de118b1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a3a7aab052f8d501f408313863de118b1">getLonDegrees</a> (const double *const v)</td></tr>
<tr class="memdesc:a3a7aab052f8d501f408313863de118b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 3-component unit vector to a longitude, in degrees.  <a href="a00275.html#a3a7aab052f8d501f408313863de118b1">More...</a><br /></td></tr>
<tr class="separator:a3a7aab052f8d501f408313863de118b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ffa23c0bc7ffb57b72193de82c0c1"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ab43ffa23c0bc7ffb57b72193de82c0c1">getLonLatString</a> (const double *const v)</td></tr>
<tr class="separator:ab43ffa23c0bc7ffb57b72193de82c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44854ccd758f6bdbe8729080086cc9a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a44854ccd758f6bdbe8729080086cc9a8">getTransform</a> (const double *const u, const double *const v, double **const t)</td></tr>
<tr class="memdesc:a44854ccd758f6bdbe8729080086cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform is a 3 x 3 matrix such that when a vector is multiplied by transform, the vector will be projected onto the plane of this GreatCircle.  <a href="a00275.html#a44854ccd758f6bdbe8729080086cc9a8">More...</a><br /></td></tr>
<tr class="separator:a44854ccd758f6bdbe8729080086cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790f25f4b9f83e7409ecb99dedfc50c1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a790f25f4b9f83e7409ecb99dedfc50c1">getTriangleArea</a> (const double *const v0, const double *const v1, const double *const v2)</td></tr>
<tr class="separator:a790f25f4b9f83e7409ecb99dedfc50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf58f689c6ff11e4540bd8412682a99d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adf58f689c6ff11e4540bd8412682a99d">getTriangleArea</a> (const double *const v0, const double *const v1, const double *const v2, double *work1, double *work2, double *work3)</td></tr>
<tr class="separator:adf58f689c6ff11e4540bd8412682a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceee4747dea8c9fbe1644124feade23"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a2ceee4747dea8c9fbe1644124feade23">getVector</a> (const double &amp;lat, const double &amp;lon)</td></tr>
<tr class="memdesc:a2ceee4747dea8c9fbe1644124feade23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geographic lat, lon into a geocentric unit vector.  <a href="a00275.html#a2ceee4747dea8c9fbe1644124feade23">More...</a><br /></td></tr>
<tr class="separator:a2ceee4747dea8c9fbe1644124feade23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e794db81f67cfb3b20c8c0022989ec1"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a5e794db81f67cfb3b20c8c0022989ec1">getVector</a> (const double &amp;lat, const double &amp;lon, double *v)</td></tr>
<tr class="memdesc:a5e794db81f67cfb3b20c8c0022989ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geographic lat, lon into a geocentric unit vector.  <a href="a00275.html#a5e794db81f67cfb3b20c8c0022989ec1">More...</a><br /></td></tr>
<tr class="separator:a5e794db81f67cfb3b20c8c0022989ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee76ff0e6f2b8ab6a37505841ee4f3"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a75ee76ff0e6f2b8ab6a37505841ee4f3">getVectorDegrees</a> (const double &amp;lat, const double &amp;lon)</td></tr>
<tr class="memdesc:a75ee76ff0e6f2b8ab6a37505841ee4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geographic lat, lon into a geocentric unit vector.  <a href="a00275.html#a75ee76ff0e6f2b8ab6a37505841ee4f3">More...</a><br /></td></tr>
<tr class="separator:a75ee76ff0e6f2b8ab6a37505841ee4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a67b9f39942426906887d5c351ddaf3"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a3a67b9f39942426906887d5c351ddaf3">getVectorDegrees</a> (const double &amp;lat, const double &amp;lon, double *v)</td></tr>
<tr class="memdesc:a3a67b9f39942426906887d5c351ddaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geographic lat, lon into a geocentric unit vector.  <a href="a00275.html#a3a67b9f39942426906887d5c351ddaf3">More...</a><br /></td></tr>
<tr class="separator:a3a67b9f39942426906887d5c351ddaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35e607c464f731d33b0cda2ccd298ca"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ae35e607c464f731d33b0cda2ccd298ca">getVersion</a> ()</td></tr>
<tr class="memdesc:ae35e607c464f731d33b0cda2ccd298ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current GeoTess version.  <a href="a00275.html#ae35e607c464f731d33b0cda2ccd298ca">More...</a><br /></td></tr>
<tr class="separator:ae35e607c464f731d33b0cda2ccd298ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff6c582160a3337b1e1e02281010987"><td class="memItemLeft" align="right" valign="top">static double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a8ff6c582160a3337b1e1e02281010987">inverse_3x3</a> (double **m)</td></tr>
<tr class="memdesc:a8ff6c582160a3337b1e1e02281010987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the inverse of 3x3 matrix m.  <a href="a00275.html#a8ff6c582160a3337b1e1e02281010987">More...</a><br /></td></tr>
<tr class="separator:a8ff6c582160a3337b1e1e02281010987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d68448b30750c721cd3447dea2a4834"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a3d68448b30750c721cd3447dea2a4834">isPole</a> (const double *const u)</td></tr>
<tr class="memdesc:a3d68448b30750c721cd3447dea2a4834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if unit vector u is very close to [0, 0, +/- 1].  <a href="a00275.html#a3d68448b30750c721cd3447dea2a4834">More...</a><br /></td></tr>
<tr class="separator:a3d68448b30750c721cd3447dea2a4834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6068f643d6104ec7b537afe563ab5f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a8a6068f643d6104ec7b537afe563ab5f">length</a> (const double *const u)</td></tr>
<tr class="memdesc:a8a6068f643d6104ec7b537afe563ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of a 3-element vector.  <a href="a00275.html#a8a6068f643d6104ec7b537afe563ab5f">More...</a><br /></td></tr>
<tr class="separator:a8a6068f643d6104ec7b537afe563ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca47ee1d1523ae0e023d0683abddc96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adca47ee1d1523ae0e023d0683abddc96">move</a> (const double *const w, const double *const vtp, double a, double *const u)</td></tr>
<tr class="memdesc:adca47ee1d1523ae0e023d0683abddc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move unit vector w in direction of vtp by distance a and store result in u.  <a href="a00275.html#adca47ee1d1523ae0e023d0683abddc96">More...</a><br /></td></tr>
<tr class="separator:adca47ee1d1523ae0e023d0683abddc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b978b720cac1b965f2f73147cde456"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ae6b978b720cac1b965f2f73147cde456">moveDistAz</a> (const double *const w, double distance, double <a class="el" href="a00275.html#adcdab7c30b907e3833844b75df874222">azimuth</a>, double *const u)</td></tr>
<tr class="memdesc:ae6b978b720cac1b965f2f73147cde456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move unit vector w specified distance in direction given by azimuth and return the result in u.  <a href="a00275.html#ae6b978b720cac1b965f2f73147cde456">More...</a><br /></td></tr>
<tr class="separator:ae6b978b720cac1b965f2f73147cde456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff847527eb0644c2e2ca802a0bbe8ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adff847527eb0644c2e2ca802a0bbe8ee">moveNorth</a> (const double *const x, double distance, double *const z)</td></tr>
<tr class="memdesc:adff847527eb0644c2e2ca802a0bbe8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unit vector that is distance radians due north of positon x.  <a href="a00275.html#adff847527eb0644c2e2ca802a0bbe8ee">More...</a><br /></td></tr>
<tr class="separator:adff847527eb0644c2e2ca802a0bbe8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92d25ffce5fa9968848cfb5af7f712"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#aeb92d25ffce5fa9968848cfb5af7f712">normalize</a> (double *const u)</td></tr>
<tr class="memdesc:aeb92d25ffce5fa9968848cfb5af7f712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the input vector to unit length.  <a href="a00275.html#aeb92d25ffce5fa9968848cfb5af7f712">More...</a><br /></td></tr>
<tr class="separator:aeb92d25ffce5fa9968848cfb5af7f712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae7d4e420db40b6851f77dca3e538c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#adae7d4e420db40b6851f77dca3e538c6">normalizeFast</a> (double *const u)</td></tr>
<tr class="memdesc:adae7d4e420db40b6851f77dca3e538c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the input vector to unit length.  <a href="a00275.html#adae7d4e420db40b6851f77dca3e538c6">More...</a><br /></td></tr>
<tr class="separator:adae7d4e420db40b6851f77dca3e538c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5042e541f8e5f5de251ba06a145e91c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ac5042e541f8e5f5de251ba06a145e91c">parallel</a> (const double *const u, const double *const v)</td></tr>
<tr class="memdesc:ac5042e541f8e5f5de251ba06a145e91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if unit vector u and v are parallel or very close to it.  <a href="a00275.html#ac5042e541f8e5f5de251ba06a145e91c">More...</a><br /></td></tr>
<tr class="separator:ac5042e541f8e5f5de251ba06a145e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad50acfc9f86b05c9262ffe7fc578f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#aa9ad50acfc9f86b05c9262ffe7fc578f">rotate</a> (const double *const x, const double *const p, double a, double *const z)</td></tr>
<tr class="memdesc:aa9ad50acfc9f86b05c9262ffe7fc578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate unit vector x clockwise around unit vector p, by angle a.  <a href="a00275.html#aa9ad50acfc9f86b05c9262ffe7fc578f">More...</a><br /></td></tr>
<tr class="separator:aa9ad50acfc9f86b05c9262ffe7fc578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ff2eab3ea2e55a2a5c20c438161885"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ae4ff2eab3ea2e55a2a5c20c438161885">scalarTripleProduct</a> (const double *const v0, const double *const v1, const double *const v2)</td></tr>
<tr class="memdesc:ae4ff2eab3ea2e55a2a5c20c438161885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the scalar triple product of 3 3-component vectors: (v0 cross v1) dot v2.  <a href="a00275.html#ae4ff2eab3ea2e55a2a5c20c438161885">More...</a><br /></td></tr>
<tr class="separator:ae4ff2eab3ea2e55a2a5c20c438161885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a33ebd2e2ec985de5c393e84ff4b283"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a8a33ebd2e2ec985de5c393e84ff4b283">transform</a> (const double *x, double const *const *const t, double *const g)</td></tr>
<tr class="memdesc:a8a33ebd2e2ec985de5c393e84ff4b283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector x onto the plane of a great circle.  <a href="a00275.html#a8a33ebd2e2ec985de5c393e84ff4b283">More...</a><br /></td></tr>
<tr class="separator:a8a33ebd2e2ec985de5c393e84ff4b283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16742942c814cb0e56093b2b5bfc8ba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ac16742942c814cb0e56093b2b5bfc8ba">vectorTripleProduct</a> (const double *const v0, const double *const v1, const double *const v2, double *const rslt)</td></tr>
<tr class="memdesc:ac16742942c814cb0e56093b2b5bfc8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized vector triple product (v0 x v1) x v2 and store result in rslt.  <a href="a00275.html#ac16742942c814cb0e56093b2b5bfc8ba">More...</a><br /></td></tr>
<tr class="separator:ac16742942c814cb0e56093b2b5bfc8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6436ceb5a8a2e58855e98eb592a7c88"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#ac6436ceb5a8a2e58855e98eb592a7c88">vectorTripleProductNorthPole</a> (const double *const u, double *const w)</td></tr>
<tr class="memdesc:ac6436ceb5a8a2e58855e98eb592a7c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized vector triple product (u x northPole) x u and store result in w.  <a href="a00275.html#ac6436ceb5a8a2e58855e98eb592a7c88">More...</a><br /></td></tr>
<tr class="separator:ac6436ceb5a8a2e58855e98eb592a7c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a70dede101812281603f492f3154757eb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html#a70dede101812281603f492f3154757eb">approximateLatitudes</a></td></tr>
<tr class="memdesc:a70dede101812281603f492f3154757eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then an approximate algorithm will be used to convert back and forth between geocentric and geographic latitudes.  <a href="a00275.html#a70dede101812281603f492f3154757eb">More...</a><br /></td></tr>
<tr class="separator:a70dede101812281603f492f3154757eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Collection of static functions to manipulate geographic information. </p>
<p >The Utils class provides basic static utility functions for GeoTess to manipulate geographic information. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad908fd8b35ccaec215d7eae849aafadf" name="ad908fd8b35ccaec215d7eae849aafadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad908fd8b35ccaec215d7eae849aafadf">&#9670;&nbsp;</a></span>GeoTessUtils()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geotess::GeoTessUtils::GeoTessUtils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a2d9340ce3c08bc0afb853882e7f9043f" name="a2d9340ce3c08bc0afb853882e7f9043f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9340ce3c08bc0afb853882e7f9043f">&#9670;&nbsp;</a></span>~GeoTessUtils()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geotess::GeoTessUtils::~GeoTessUtils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35c94d177a5060a57f1f7e5c77b75175" name="a35c94d177a5060a57f1f7e5c77b75175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c94d177a5060a57f1f7e5c77b75175">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::angle </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular distance in radians between two unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>a 3 component unit vector </td></tr>
    <tr><td class="paramname">v1</td><td>a 3 component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>angular distance in radians. </dd></dl>

</div>
</div>
<a id="af95f9799b0190bb15c4b15bad0701cdf" name="af95f9799b0190bb15c4b15bad0701cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95f9799b0190bb15c4b15bad0701cdf">&#9670;&nbsp;</a></span>angleDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::angleDegrees </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular distance in degrees between two unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>a 3 component unit vector </td></tr>
    <tr><td class="paramname">v1</td><td>a 3 component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>angular distance in degrees. </dd></dl>

</div>
</div>
<a id="adcdab7c30b907e3833844b75df874222" name="adcdab7c30b907e3833844b75df874222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdab7c30b907e3833844b75df874222">&#9670;&nbsp;</a></span>azimuth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::azimuth </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>errorValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the azimuth from unit vectors v1 to v2. </p>
<p >Result will be between -PI and PI radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The point from which the azimuth will be directed toward v2. </td></tr>
    <tr><td class="paramname">v2</td><td>The point to which the azimuth will be directed from v1. </td></tr>
    <tr><td class="paramname">errorValue</td><td>if v1 and v2 are parallel, or if v1 is either the north or south pole, then return errorValue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the azimuth from v1 to v2, in radians clockwise from north, or errorValue </dd></dl>

</div>
</div>
<a id="a1518159e5f85502224342a1968c5a256" name="a1518159e5f85502224342a1968c5a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1518159e5f85502224342a1968c5a256">&#9670;&nbsp;</a></span>azimuthDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::azimuthDegrees </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>errorValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the azimuth from unit vectors v1 to v2. </p>
<p >Result will be between -180 and 180 degrees</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The point from which the azimuth will be directed toward v2. </td></tr>
    <tr><td class="paramname">v2</td><td>The point to which the azimuth will be directed from v1. </td></tr>
    <tr><td class="paramname">errorValue</td><td>if v1 and v2 are parallel, or if v1 is either the north or south pole, then return errorValue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the azimuth from v1 to v2, in degrees clockwise from north, or errorValue </dd></dl>

</div>
</div>
<a id="a04b6b0fe4fd46cc35a6bc67acb064731" name="a04b6b0fe4fd46cc35a6bc67acb064731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b6b0fe4fd46cc35a6bc67acb064731">&#9670;&nbsp;</a></span>center() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::center </td>
          <td>(</td>
          <td class="paramtype">double const *const *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the normalized vector sum of the supplied unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>one or more unit vectors </td></tr>
    <tr><td class="paramname">n</td><td>size of v </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normalized vector sum of the supplied unit vectors. </dd></dl>

</div>
</div>
<a id="a1e969b48825320f3be11ac7128f9c950" name="a1e969b48825320f3be11ac7128f9c950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e969b48825320f3be11ac7128f9c950">&#9670;&nbsp;</a></span>center() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::center </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the normalized vector sum of the supplied unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>one or more unit vectors </td></tr>
    <tr><td class="paramname">x</td><td>the 3-element array of double in which to place the computed unit vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616dd66a2f8d3e7b9de34246a30e389f" name="a616dd66a2f8d3e7b9de34246a30e389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616dd66a2f8d3e7b9de34246a30e389f">&#9670;&nbsp;</a></span>circumCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::circumCenter </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given three unit vectors, v0, v1 and v2, find the circumcenter, vs. </p>
<p >The circumcenter is the unit vector of the center of a small circle that has all three unit vectors on its circumference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td></td></tr>
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
    <tr><td class="paramname">vs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aa54a8b6796c60e7ae5134acbc9587c" name="a3aa54a8b6796c60e7ae5134acbc9587c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa54a8b6796c60e7ae5134acbc9587c">&#9670;&nbsp;</a></span>circumCenterPlus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::circumCenterPlus </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given three unit vectors, v0, v1 and v2, find the circumcenter, vs. </p>
<p >The circumcenter is the unit vector of the center of a small circle that has all three unit vectors on its circumference. Vectors must be specified in clockwise order. The fourth element of returned circumcenter is the dot product of the new circumcenter with one of the vertices. In other words, cc[3] = cos(ccRadius).</p>
<p >Caller is responsible for deleting the double* returned by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td></td></tr>
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the circumCenter: a unit vector plus cos(ccRadius) </dd></dl>

</div>
</div>
<a id="adf7cf4cfff938edba6d9387e24648a15" name="adf7cf4cfff938edba6d9387e24648a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7cf4cfff938edba6d9387e24648a15">&#9670;&nbsp;</a></span>circumCenterPlus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::circumCenterPlus </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given three unit vectors, v0, v1 and v2, find the circumcenter, vs. </p>
<p >The circumcenter is the unit vector of the center of a small circle that has all three unit vectors on its circumference. The fourth element of vs is the dot product of the new circumcenter with one of the vertices. In other words, cc[3] = cos(ccRadius).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td></td></tr>
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
    <tr><td class="paramname">vs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50d31573f9e82507169a5ac471941f51" name="a50d31573f9e82507169a5ac471941f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d31573f9e82507169a5ac471941f51">&#9670;&nbsp;</a></span>circumCenterPlus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::circumCenterPlus </td>
          <td>(</td>
          <td class="paramtype">double const *const *const&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the three unit vectors, t[0], t[1] and t[2], find the circumcenter, vs. </p>
<p >The circumcenter is the unit vector of the center of a small circle that has all three unit vectors on its circumference. The fourth element of returned circumcenter is the dot product of the new circumcenter with one of the vertices. In other words, cc[3] = cos(ccRadius).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a 3 x 3 array of doubles that contains the three unit vectors of a triangle. </td></tr>
    <tr><td class="paramname">vs</td><td>a 4 element array that will be populated with the unit vector and the cos(ccRadius). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if the three input vectors do not define a triangle. </dd></dl>

</div>
</div>
<a id="a8f037c3aa3e90ef3d8c8d898c26ffa59" name="a8f037c3aa3e90ef3d8c8d898c26ffa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f037c3aa3e90ef3d8c8d898c26ffa59">&#9670;&nbsp;</a></span>class_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string geotess::GeoTessUtils::class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class name. </p>
<dl class="section return"><dt>Returns</dt><dd>class name </dd></dl>

</div>
</div>
<a id="ae420582a046dbb4aa42edcf4ea8d2ee3" name="ae420582a046dbb4aa42edcf4ea8d2ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae420582a046dbb4aa42edcf4ea8d2ee3">&#9670;&nbsp;</a></span>class_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int geotess::GeoTessUtils::class_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class size. </p>
<dl class="section return"><dt>Returns</dt><dd>class size </dd></dl>

</div>
</div>
<a id="a26bfef7508a6350c1e3bbb442133f5eb" name="a26bfef7508a6350c1e3bbb442133f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bfef7508a6350c1e3bbb442133f5eb">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::cross </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>rslt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of two 3-component vectors. </p>
<p >Result is not normalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>vector&lt;double&gt; vector one. </td></tr>
    <tr><td class="paramname">v2</td><td>vector&lt;double&gt; vector two. </td></tr>
    <tr><td class="paramname">rslt</td><td>set to v1 cross v2 Result is not a unit vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f3195758779fd3646fec23dbec3748c" name="a1f3195758779fd3646fec23dbec3748c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3195758779fd3646fec23dbec3748c">&#9670;&nbsp;</a></span>crossNormal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::crossNormal </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized cross product of two 3-component unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector one. </td></tr>
    <tr><td class="paramname">v</td><td>vector two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized cross product of u x v. Will be [0,0,0] if u and v are parallel. </dd></dl>

</div>
</div>
<a id="a4af959a66c281a40f1baa9620504b193" name="a4af959a66c281a40f1baa9620504b193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af959a66c281a40f1baa9620504b193">&#9670;&nbsp;</a></span>crossNormal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::crossNormal </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized cross product of two 3-component unit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector one. </td></tr>
    <tr><td class="paramname">v</td><td>vector two. </td></tr>
    <tr><td class="paramname">w</td><td>set to u cross v, normalized to unit length. If u cross v has zero length, w will equal (0,0,0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of u cross v prior to normalization. Guaranteed &gt;= 0. </dd></dl>

</div>
</div>
<a id="a808084382483e6d54663e37aa5ea706d" name="a808084382483e6d54663e37aa5ea706d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808084382483e6d54663e37aa5ea706d">&#9670;&nbsp;</a></span>crossNorth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::crossNorth </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized cross product of a 3-component unit vector with the north pole. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector&lt;double&gt; vector one. </td></tr>
    <tr><td class="paramname">w</td><td>set to u cross north, normalized to unit length. If u cross north has zero length, w will equal (0,0,0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of u cross north prior to normalization. Guaranteed &gt;= 0. </dd></dl>

</div>
</div>
<a id="a3869e0326dd5b1036c90049403160dcb" name="a3869e0326dd5b1036c90049403160dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3869e0326dd5b1036c90049403160dcb">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::dot </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dot product of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>a 3 component vector </td></tr>
    <tr><td class="paramname">v1</td><td>a 3 component vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dot product </dd></dl>

</div>
</div>
<a id="a063c1291eee7a438280e8d4b190c4f81" name="a063c1291eee7a438280e8d4b190c4f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c1291eee7a438280e8d4b190c4f81">&#9670;&nbsp;</a></span>eulerRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::eulerRotation </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>euler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an Euler rotation matrix computed from 3 Euler rotation angles using method <a class="el" href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc" title="Given three Euler angles in radians, retrieve the Euler rotation matrix.">getEulerMatrix()</a>, apply the rotation to 3-component unit vector u and return the result in a new 3-component unit vector. </p>
<p >Reference: <a href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>3-component unit vector to be rotated </td></tr>
    <tr><td class="paramname">euler</td><td>3x3 euler rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rotated 3-component unit vector </dd></dl>

</div>
</div>
<a id="af4299f19fc8acef0fbb02353f232d657" name="af4299f19fc8acef0fbb02353f232d657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4299f19fc8acef0fbb02353f232d657">&#9670;&nbsp;</a></span>eulerRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::eulerRotation </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>euler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an Euler rotation matrix computed from 3 Euler rotation angles using method <a class="el" href="a00275.html#a48be48b8f6d0c6140a4b673bef1374cc" title="Given three Euler angles in radians, retrieve the Euler rotation matrix.">getEulerMatrix()</a>, apply the rotation to 3-component unit vector u and return the result in unit vector v. </p>
<p >u and v can be references to the same array. </p>
<p >Reference: <a href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>3-component unit vector to be rotated </td></tr>
    <tr><td class="paramname">euler</td><td>3x3 euler rotation matrix. </td></tr>
    <tr><td class="paramname">v</td><td>rotated 3-component unit vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5747bfd26b78e8ce835d24c1699d847" name="ac5747bfd26b78e8ce835d24c1699d847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5747bfd26b78e8ce835d24c1699d847">&#9670;&nbsp;</a></span>getDistance3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getDistance3D </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two unit vectors and their radii, return the straight line separation between their tips. </p>
<p >Assuming that the radii are in km, the result will also be in km.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>Point 0 unit vector. </td></tr>
    <tr><td class="paramname">r0</td><td>Point 0 length (km). </td></tr>
    <tr><td class="paramname">v1</td><td>Point 1 unit vector. </td></tr>
    <tr><td class="paramname">r1</td><td>Point 1 length (km). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between tip of v0*r0 and v1*r1, in km. </dd></dl>

</div>
</div>
<a id="a8506836f063f685d9884415e22f3ab7b" name="a8506836f063f685d9884415e22f3ab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8506836f063f685d9884415e22f3ab7b">&#9670;&nbsp;</a></span>getEarthRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getEarthRadius </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the radius of the Earth in km at the position specified by an Earth-centered unit vector. </p>
<p >Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Earth-centered unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>radius of the Earth in km at specified position. </dd></dl>

</div>
</div>
<a id="a48be48b8f6d0c6140a4b673bef1374cc" name="a48be48b8f6d0c6140a4b673bef1374cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48be48b8f6d0c6140a4b673bef1374cc">&#9670;&nbsp;</a></span>getEulerMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ** geotess::GeoTessUtils::getEulerMatrix </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given three Euler angles in radians, retrieve the Euler rotation matrix. </p>
<p >Euler rotation angles: </p>
<p >Given two coordinate systems xyz and XYZ with common origin, starting with the axis z and Z overlapping, the position of the second can be specified in terms of the first using three rotations with angles A, B, C as follows:</p>
<ol>
<li>
Rotate the xyz-system about the z-axis by A. </li>
<li>
Rotate the xyz-system again about the now rotated x-axis by B. </li>
<li>
Rotate the xyz-system a third time about the new z-axis by C. </li>
</ol>
<p >Clockwise rotations, when looking in direction of vector, are positive. </p>
<p >Reference: <a href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>double[3] the 3 Euler rotation angles, phi, theta and psi, in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double[3][3] Euler rotation matrix </dd></dl>

</div>
</div>
<a id="a25bd1dd386e185bfd21afbb117a4875c" name="a25bd1dd386e185bfd21afbb117a4875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd1dd386e185bfd21afbb117a4875c">&#9670;&nbsp;</a></span>getEulerRotationAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getEulerRotationAngles </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a location, retrieve the Euler rotation angles, in radians, that will rotate the north pole ([0., 0., 1. </p>
<p >]) to the specified location. The 3 angles are: longitude+PI/2, geocentric colatitude, -PI/2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unitVector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>euler rotation angles in radians. </dd></dl>

</div>
</div>
<a id="a1fd3a9cbe00c33e01f4809548ecfc79e" name="a1fd3a9cbe00c33e01f4809548ecfc79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd3a9cbe00c33e01f4809548ecfc79e">&#9670;&nbsp;</a></span>getGeocentricLat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessUtils::getGeocentricLat </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return geocentric latitude given a geographic latitude using the WGS84 ellipsoid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geographic latitude in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geocentric latitude in radians </dd></dl>

</div>
</div>
<a id="a66f6f3dd7e5ef8a712f6ccae14282496" name="a66f6f3dd7e5ef8a712f6ccae14282496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f6f3dd7e5ef8a712f6ccae14282496">&#9670;&nbsp;</a></span>getGeographicLat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geotess::GeoTessUtils::getGeographicLat </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return geographic latitude given a geocentric latitude using the WGS84 ellipsoid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geocentric latitude in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geographic latitude in radians </dd></dl>

</div>
</div>
<a id="abaa54c50cf12cba7cbcbfa784e2aaf1d" name="abaa54c50cf12cba7cbcbfa784e2aaf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa54c50cf12cba7cbcbfa784e2aaf1d">&#9670;&nbsp;</a></span>getGreatCircle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ** geotess::GeoTessUtils::getGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azimuth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array, which is the structure returned by this method. A great circle can be passed to the method <a class="el" href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCirclePoint()</a> to retrieve a unit vector that is on the great circle and located some distance from the first point of the great circle. </p>
<p >This method returns a great circle that is defined by an initial point and an azimuth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a unit vector that will be the first point on the great circle. </td></tr>
    <tr><td class="paramname">azimuth</td><td>a direction, in radians, in which to move relative to v in order to define the great circle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 2 x 3 array specifying two unit vectors. The first one is a clone of unit vector v passed as an argument to this method. The second is located 90 degrees away from v in the direction specified by azimuth. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00163.html" title="An exception class for all GeoTess objects.">GeoTessException</a></td><td>if v is located at north or south pole. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2242d24108f33e4a9c4453771236938a" name="a2242d24108f33e4a9c4453771236938a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2242d24108f33e4a9c4453771236938a">&#9670;&nbsp;</a></span>getGreatCircle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::getGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **const&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array, which is the structure returned by this method. A great circle can be passed to the method <a class="el" href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCirclePoint()</a> to retrieve a unit vector that is on the great circle and located some distance from the first point of the great circle. </p>
<p >This method returns a great circle that is defined by an initial point and an azimuth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a unit vector that will be the first point on the great circle. </td></tr>
    <tr><td class="paramname">azimuth</td><td>a direction, in radians, in which to move relative to v in order to define the great circle </td></tr>
    <tr><td class="paramname">gc</td><td>a 2 x 3 array specifying two unit vectors. The first one is a clone of unit vector v passed as an argument to this method. The second is located 90 degrees away from v in the direction specified by azimuth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00163.html" title="An exception class for all GeoTess objects.">GeoTessException</a></td><td>if v is located at north or south pole. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab99db79c6ce26361a3a1d3a07efcf214" name="ab99db79c6ce26361a3a1d3a07efcf214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99db79c6ce26361a3a1d3a07efcf214">&#9670;&nbsp;</a></span>getGreatCircle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ** geotess::GeoTessUtils::getGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array, which is the structure returned by this method. A great circle can be passed to the method <a class="el" href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCirclePoint()</a> to retrieve a unit vector that is on the great circle and located some distance from the first point of the great circle. </p>
<p >This method returns a great circle that is computed from two unit vectors that are not necessarily 90 degrees apart.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>the first point on the great circle </td></tr>
    <tr><td class="paramname">v1</td><td>some other point that is also on the great circle but which is not necessarily 90 degrees away from v0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 2 x 3 array specifying two unit vectors. The first one is a clone of unit vector v0 passed as first argument to this method. The second is located 90 degrees away from v0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00163.html" title="An exception class for all GeoTess objects.">GeoTessException</a></td><td>if v0 and v1 are parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9763a021b66125eec799f99c47ba7306" name="a9763a021b66125eec799f99c47ba7306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9763a021b66125eec799f99c47ba7306">&#9670;&nbsp;</a></span>getGreatCircle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::getGreatCircle </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **const&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array, which is the structure returned by this method. A great circle can be passed to the method <a class="el" href="a00275.html#a13695d9fff836c8ac16b4c5b6567688a" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCirclePoint()</a> to retrieve a unit vector that is on the great circle and located some distance from the first point of the great circle. </p>
<p >This method returns a great circle that is computed from two unit vectors that are not necessarily 90 degrees apart.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>the first point on the great circle </td></tr>
    <tr><td class="paramname">v1</td><td>some other point that is also on the great circle but which is not necessarily 90 degrees away from v0. </td></tr>
    <tr><td class="paramname">gc</td><td>a 2 x 3 array specifying two unit vectors. The first one is a clone of unit vector v0 passed as first argument to this method. The second is located 90 degrees away from v0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00163.html" title="An exception class for all GeoTess objects.">GeoTessException</a></td><td>if v0 and v1 are parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13695d9fff836c8ac16b4c5b6567688a" name="a13695d9fff836c8ac16b4c5b6567688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13695d9fff836c8ac16b4c5b6567688a">&#9670;&nbsp;</a></span>getGreatCirclePoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getGreatCirclePoint </td>
          <td>(</td>
          <td class="paramtype">double const *const *const&#160;</td>
          <td class="paramname"><em>greatCircle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array and one can be obtained by calling one of the <a class="el" href="a00275.html#ab99db79c6ce26361a3a1d3a07efcf214" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCircle()</a> methods. </p>
<p >In this method, a great circle and a distance are specified and a point is returned which is on the great circle path and is the specified distance away from the first point of the great circle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">greatCircle</td><td>a great circle structure </td></tr>
    <tr><td class="paramname">distance</td><td>distance in radians from first point of great circle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit vector of point which is on great circle and located specified distance away from first point of great circle. </dd></dl>

</div>
</div>
<a id="a11f167c1ca0bb27227a6c7a93490a90e" name="a11f167c1ca0bb27227a6c7a93490a90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f167c1ca0bb27227a6c7a93490a90e">&#9670;&nbsp;</a></span>getGreatCirclePoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::getGreatCirclePoint </td>
          <td>(</td>
          <td class="paramtype">double const *const *const&#160;</td>
          <td class="paramname"><em>greatCircle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A great circle is defined by two unit vectors that are 90 degrees apart. </p>
<p >A great circle is stored in a double[2][3] array and one can be obtained by calling one of the <a class="el" href="a00275.html#ab99db79c6ce26361a3a1d3a07efcf214" title="A great circle is defined by two unit vectors that are 90 degrees apart.">getGreatCircle()</a> methods. </p>
<p >In this method, a great circle and a distance are specified and a point is returned which is on the great circle path and is the specified distance away from the first point of the great circle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">greatCircle</td><td>a great circle structure </td></tr>
    <tr><td class="paramname">distance</td><td>distance in radians from first point of great circle </td></tr>
    <tr><td class="paramname">v</td><td>unit vector of point which is on great circle and located specified distance away from first point of great circle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb34aec60ddf70ea9b8d73699a37a30" name="a5fb34aec60ddf70ea9b8d73699a37a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb34aec60ddf70ea9b8d73699a37a30">&#9670;&nbsp;</a></span>getGreatCirclePoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int geotess::GeoTessUtils::getGreatCirclePoints </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of points that would be required to populate a great circle path from point A to point B with equally spaced points given that the spacing can be no greater than delta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptA</td><td>unit vector of first point on great circle (input) </td></tr>
    <tr><td class="paramname">ptB</td><td>unit vector of last point on great circle (input) </td></tr>
    <tr><td class="paramname">delta</td><td>desired point spacing in radians (input) </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, returned points will be located in the centers of equal size path increments. If false, first point will coincide with ptA, last point will coincide with ptB and the remaining points will be equally spaced in between. (input) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of points required </dd></dl>

</div>
</div>
<a id="a2b8800373d5ccd2d2f004ce27545f04b" name="a2b8800373d5ccd2d2f004ce27545f04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8800373d5ccd2d2f004ce27545f04b">&#9670;&nbsp;</a></span>getGreatCirclePoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getGreatCirclePoints </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>npoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the unit vectors of a bunch of points distributed along a great circle path between two points. </p>
<p >Caller specifies desired spacing of the points, not the number of points. The acutal spacing will generally be somewhat less than the request spacing in order that an integral number of points can be equally spaced along the path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptA</td><td>unit vector of first point on great circle (input) </td></tr>
    <tr><td class="paramname">ptB</td><td>unit vector of last point on great circle (input) </td></tr>
    <tr><td class="paramname">delta</td><td>desired point spacing in radians (input) </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, returned points will be located in the centers of equal size path increments. If false, first point will coincide with ptA, last point will coincide with ptB and the remaining points will be equally spaced in between. (input) </td></tr>
    <tr><td class="paramname">points</td><td>an npoints by 3 array that will be populated with computed points. Must be large enough to hold all the computed points. </td></tr>
    <tr><td class="paramname">npoints</td><td>the number of points being returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual point spacing in radians </dd></dl>

</div>
</div>
<a id="ab761184340d27dc1d5c8974bb654204b" name="ab761184340d27dc1d5c8974bb654204b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab761184340d27dc1d5c8974bb654204b">&#9670;&nbsp;</a></span>getGreatCirclePoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getGreatCirclePoints </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>onCenters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the unit vectors of a bunch of points distributed along a great circle path between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptA</td><td>unit vector of first point on great circle (input) </td></tr>
    <tr><td class="paramname">ptB</td><td>unit vector of last point on great circle (input) </td></tr>
    <tr><td class="paramname">npoints</td><td>the number of points to distribute along the great circle path (input) </td></tr>
    <tr><td class="paramname">onCenters</td><td>if true, returned points will be located in the centers of equal size path increments. If false, first point will coincide with ptA, last point will coincide with ptB and the remaining points will be equally spaced in between. (input) </td></tr>
    <tr><td class="paramname">points</td><td>an npoints by 3 array that will be populated with computed points. Must be large enough to hold all the computed points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual point spacing in radians </dd></dl>

</div>
</div>
<a id="a0e89df0590bf5c1d75bf947bf8b3fae6" name="a0e89df0590bf5c1d75bf947bf8b3fae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e89df0590bf5c1d75bf947bf8b3fae6">&#9670;&nbsp;</a></span>getLat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getLat </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 3-component unit vector to geographic latitude, in radians. </p>
<p >Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>3-component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geographic latitude in radians. </dd></dl>

</div>
</div>
<a id="ad03715e35fdbdc69885c3494eaa32ace" name="ad03715e35fdbdc69885c3494eaa32ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03715e35fdbdc69885c3494eaa32ace">&#9670;&nbsp;</a></span>getLatDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getLatDegrees </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 3-component unit vector to geographic latitude, in degrees. </p>
<p >Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>3-component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geographic latitude in degrees. </dd></dl>

</div>
</div>
<a id="aa096dd35c28a97ecf2a353d03daace6b" name="aa096dd35c28a97ecf2a353d03daace6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa096dd35c28a97ecf2a353d03daace6b">&#9670;&nbsp;</a></span>getLatLonString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string geotess::GeoTessUtils::getLatLonString </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>unit vector to be converted to lat, lon string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a String of lat,lon in degrees formatted with "%10.6f %11.6f" </dd></dl>

</div>
</div>
<a id="aab9626244c7506dd83498e70a2dace07" name="aab9626244c7506dd83498e70a2dace07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9626244c7506dd83498e70a2dace07">&#9670;&nbsp;</a></span>getLon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getLon </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 3-component unit vector to a longitude, in radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>3 component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>longitude in radians. </dd></dl>

</div>
</div>
<a id="a3a7aab052f8d501f408313863de118b1" name="a3a7aab052f8d501f408313863de118b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7aab052f8d501f408313863de118b1">&#9670;&nbsp;</a></span>getLonDegrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getLonDegrees </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 3-component unit vector to a longitude, in degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>3 component unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>longitude in degrees. </dd></dl>

</div>
</div>
<a id="ab43ffa23c0bc7ffb57b72193de82c0c1" name="ab43ffa23c0bc7ffb57b72193de82c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ffa23c0bc7ffb57b72193de82c0c1">&#9670;&nbsp;</a></span>getLonLatString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string geotess::GeoTessUtils::getLonLatString </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>unit vector to be converted to lon,lat string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a String of lon,lat in degrees formatted with "%11.6f %10.6f" </dd></dl>

</div>
</div>
<a id="a44854ccd758f6bdbe8729080086cc9a8" name="a44854ccd758f6bdbe8729080086cc9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44854ccd758f6bdbe8729080086cc9a8">&#9670;&nbsp;</a></span>getTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::getTransform </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform is a 3 x 3 matrix such that when a vector is multiplied by transform, the vector will be projected onto the plane of this GreatCircle. </p>
<p >The z direction will point out of the plane of the great circle in the direction of the observer (lastPoint cross firstPoint; parallel to normal). The y direction will correspond to the mean of firstPoint and lastPoint. The x direction will correspond to y cross z, forming a right handed coordinate system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a 3-component unit vector defining start of great circle </td></tr>
    <tr><td class="paramname">v</td><td>a 3-component unit vector defining end of great circle </td></tr>
    <tr><td class="paramname">t</td><td>3 x 3 array that will be populated with the transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790f25f4b9f83e7409ecb99dedfc50c1" name="a790f25f4b9f83e7409ecb99dedfc50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790f25f4b9f83e7409ecb99dedfc50c1">&#9670;&nbsp;</a></span>getTriangleArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getTriangleArea </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>first corner of triangle </td></tr>
    <tr><td class="paramname">v1</td><td>second corner of triangle </td></tr>
    <tr><td class="paramname">v2</td><td>third corner of triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of a triangle defined by three 3-component vectors </dd></dl>

</div>
</div>
<a id="adf58f689c6ff11e4540bd8412682a99d" name="adf58f689c6ff11e4540bd8412682a99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf58f689c6ff11e4540bd8412682a99d">&#9670;&nbsp;</a></span>getTriangleArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::getTriangleArea </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>first corner of triangle </td></tr>
    <tr><td class="paramname">v1</td><td>second corner of triangle </td></tr>
    <tr><td class="paramname">v2</td><td>third corner of triangle </td></tr>
    <tr><td class="paramname">work1</td><td>a double[3] used as work space </td></tr>
    <tr><td class="paramname">work2</td><td>a double[3] used as work space </td></tr>
    <tr><td class="paramname">work3</td><td>a double[3] used as work space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of a triangle defined by three 3-component vectors </dd></dl>

</div>
</div>
<a id="a2ceee4747dea8c9fbe1644124feade23" name="a2ceee4747dea8c9fbe1644124feade23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceee4747dea8c9fbe1644124feade23">&#9670;&nbsp;</a></span>getVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getVector </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geographic lat, lon into a geocentric unit vector. </p>
<p >The x-component points toward lat,lon = 0, 0. The y-component points toward lat,lon = 0, PI/2. The z-component points toward north pole. Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geographic latitude in radians. </td></tr>
    <tr><td class="paramname">lon</td><td>longitude in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3 component unit vector. </dd></dl>

</div>
</div>
<a id="a5e794db81f67cfb3b20c8c0022989ec1" name="a5e794db81f67cfb3b20c8c0022989ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e794db81f67cfb3b20c8c0022989ec1">&#9670;&nbsp;</a></span>getVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getVector </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geographic lat, lon into a geocentric unit vector. </p>
<p >The x-component points toward lat,lon = 0, 0. The y-component points toward lat,lon = 0, PI/2 The z-component points toward north pole. Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geographic latitude in radians. </td></tr>
    <tr><td class="paramname">lon</td><td>longitude in radians. </td></tr>
    <tr><td class="paramname">v</td><td>3-component unit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to v </dd></dl>

</div>
</div>
<a id="a75ee76ff0e6f2b8ab6a37505841ee4f3" name="a75ee76ff0e6f2b8ab6a37505841ee4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ee76ff0e6f2b8ab6a37505841ee4f3">&#9670;&nbsp;</a></span>getVectorDegrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getVectorDegrees </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geographic lat, lon into a geocentric unit vector. </p>
<p >The x-component points toward lat,lon = 0, 0. The y-component points toward lat,lon = 0, 90. The z-component points toward north pole. Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geographic latitude in degrees. </td></tr>
    <tr><td class="paramname">lon</td><td>longitude in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3 component unit vector. </dd></dl>

</div>
</div>
<a id="a3a67b9f39942426906887d5c351ddaf3" name="a3a67b9f39942426906887d5c351ddaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a67b9f39942426906887d5c351ddaf3">&#9670;&nbsp;</a></span>getVectorDegrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double * geotess::GeoTessUtils::getVectorDegrees </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geographic lat, lon into a geocentric unit vector. </p>
<p >The x-component points toward lat,lon = 0, 0. The y-component points toward lat,lon = 0, 90. The z-component points toward north pole. Uses the WGS84 ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>geographic latitude in degrees. </td></tr>
    <tr><td class="paramname">lon</td><td>longitude in degrees. </td></tr>
    <tr><td class="paramname">v</td><td>3 component unit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to v </dd></dl>

</div>
</div>
<a id="ae35e607c464f731d33b0cda2ccd298ca" name="ae35e607c464f731d33b0cda2ccd298ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35e607c464f731d33b0cda2ccd298ca">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string geotess::GeoTessUtils::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current GeoTess version. </p>
<dl class="section return"><dt>Returns</dt><dd>the current GeoTess version </dd></dl>

</div>
</div>
<a id="a8ff6c582160a3337b1e1e02281010987" name="a8ff6c582160a3337b1e1e02281010987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff6c582160a3337b1e1e02281010987">&#9670;&nbsp;</a></span>inverse_3x3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ** geotess::GeoTessUtils::inverse_3x3 </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the inverse of 3x3 matrix m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a 3x3 matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of m. </dd></dl>

</div>
</div>
<a id="a3d68448b30750c721cd3447dea2a4834" name="a3d68448b30750c721cd3447dea2a4834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d68448b30750c721cd3447dea2a4834">&#9670;&nbsp;</a></span>isPole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::isPole </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if unit vector u is very close to [0, 0, +/- 1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if unit vector u is very close to [0, 0, +/- 1] </dd></dl>

</div>
</div>
<a id="a8a6068f643d6104ec7b537afe563ab5f" name="a8a6068f643d6104ec7b537afe563ab5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6068f643d6104ec7b537afe563ab5f">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::length </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the length of a 3-element vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>double[] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the vector. Guaranteed to be &gt;= 0. </dd></dl>

</div>
</div>
<a id="adca47ee1d1523ae0e023d0683abddc96" name="adca47ee1d1523ae0e023d0683abddc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca47ee1d1523ae0e023d0683abddc96">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::move </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>vtp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move unit vector w in direction of vtp by distance a and store result in u. </p>
<p >vtp is assumed to be a unit vector normal to w on input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>double[] </td></tr>
    <tr><td class="paramname">vtp</td><td>double[] </td></tr>
    <tr><td class="paramname">a</td><td>double </td></tr>
    <tr><td class="paramname">u</td><td>double[] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6b978b720cac1b965f2f73147cde456" name="ae6b978b720cac1b965f2f73147cde456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b978b720cac1b965f2f73147cde456">&#9670;&nbsp;</a></span>moveDistAz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::moveDistAz </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move unit vector w specified distance in direction given by azimuth and return the result in u. </p>
<p >If w is north or south pole, u will be equal to the same pole and method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>double[] unit vector of starting position </td></tr>
    <tr><td class="paramname">distance</td><td>distance to move in radians </td></tr>
    <tr><td class="paramname">azimuth</td><td>direction to move in radians </td></tr>
    <tr><td class="paramname">u</td><td>double[] unit vector of resulting position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if w is north or south pole </dd></dl>

</div>
</div>
<a id="adff847527eb0644c2e2ca802a0bbe8ee" name="adff847527eb0644c2e2ca802a0bbe8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff847527eb0644c2e2ca802a0bbe8ee">&#9670;&nbsp;</a></span>moveNorth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::moveNorth </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unit vector that is distance radians due north of positon x. </p>
<p >If x is the north or south pole, then z is set equal to x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the position to be moved. </td></tr>
    <tr><td class="paramname">distance</td><td>the distance, in radians, that x is to be moved toward the north. </td></tr>
    <tr><td class="paramname">z</td><td>the 3-element unit vector representing the position after having moved distance north. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if operation successful, false if x is north or south pole. </dd></dl>

</div>
</div>
<a id="aeb92d25ffce5fa9968848cfb5af7f712" name="aeb92d25ffce5fa9968848cfb5af7f712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92d25ffce5fa9968848cfb5af7f712">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::normalize </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize the input vector to unit length. </p>
<p >Returns the length of the vector prior to normalization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector&lt;double&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the vector prior to normalization ( &gt;= 0.) </dd></dl>

</div>
</div>
<a id="adae7d4e420db40b6851f77dca3e538c6" name="adae7d4e420db40b6851f77dca3e538c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae7d4e420db40b6851f77dca3e538c6">&#9670;&nbsp;</a></span>normalizeFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::normalizeFast </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize the input vector to unit length. </p>
<p >Unlike <a class="el" href="a00275.html#aeb92d25ffce5fa9968848cfb5af7f712" title="Normalize the input vector to unit length.">normalize()</a>, this method does not check to ensure that the length of the input vector is not zero. Only call this version if certain that the length of the vector is &gt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector&lt;double&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5042e541f8e5f5de251ba06a145e91c" name="ac5042e541f8e5f5de251ba06a145e91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5042e541f8e5f5de251ba06a145e91c">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::parallel </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if unit vector u and v are parallel or very close to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a unit vector </td></tr>
    <tr><td class="paramname">v</td><td>another unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1.-abs(dot(u,v)) &lt; 2e-15 </dd></dl>

</div>
</div>
<a id="aa9ad50acfc9f86b05c9262ffe7fc578f" name="aa9ad50acfc9f86b05c9262ffe7fc578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ad50acfc9f86b05c9262ffe7fc578f">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::rotate </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate unit vector x clockwise around unit vector p, by angle a. </p>
<p >x and z may be references to the same array. Clockwise rotation as viewed from outside the unit sphere is positive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>vector to be rotated </td></tr>
    <tr><td class="paramname">p</td><td>pole about which rotation is to occur. </td></tr>
    <tr><td class="paramname">a</td><td>double the amount of rotation, in radians. </td></tr>
    <tr><td class="paramname">z</td><td>the rotated vector, normalized to unit length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ff2eab3ea2e55a2a5c20c438161885" name="ae4ff2eab3ea2e55a2a5c20c438161885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ff2eab3ea2e55a2a5c20c438161885">&#9670;&nbsp;</a></span>scalarTripleProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double geotess::GeoTessUtils::scalarTripleProduct </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the scalar triple product of 3 3-component vectors: (v0 cross v1) dot v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>double[] </td></tr>
    <tr><td class="paramname">v1</td><td>double[] </td></tr>
    <tr><td class="paramname">v2</td><td>double[] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar triple product (v0 cross v1) dot v2 </dd></dl>

</div>
</div>
<a id="a8a33ebd2e2ec985de5c393e84ff4b283" name="a8a33ebd2e2ec985de5c393e84ff4b283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a33ebd2e2ec985de5c393e84ff4b283">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geotess::GeoTessUtils::transform </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *const *const&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector x onto the plane of a great circle. </p>
<p >Consider a great circle defined by two unti vectors, u and v. Find the transform of x by calling t = getTransform(u, v). Then call this method: transform(x, t, g), which will calculate unit vector g such that </p><ul>
<li>
g[2] is the z direction, i.e., the component of x that points out of the plane of the great circle, toward the observer (v cross u). </li>
<li>
g[1] is the y direction, i.e., the mean of u and v, and </li>
<li>
g[0] is the x direction, i.e, g[1] cross g2. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>unit vector to be transformed </td></tr>
    <tr><td class="paramname">t</td><td>transform obtained with call to <a class="el" href="a00275.html#a44854ccd758f6bdbe8729080086cc9a8" title="Transform is a 3 x 3 matrix such that when a vector is multiplied by transform, the vector will be pr...">getTransform()</a> </td></tr>
    <tr><td class="paramname">g</td><td>transformed unit vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16742942c814cb0e56093b2b5bfc8ba" name="ac16742942c814cb0e56093b2b5bfc8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16742942c814cb0e56093b2b5bfc8ba">&#9670;&nbsp;</a></span>vectorTripleProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::vectorTripleProduct </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>rslt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized vector triple product (v0 x v1) x v2 and store result in rslt. </p>
<p >It is ok if rslt is a reference to one of the input vectors. Local variables are used to ensure memory is not corrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>double[] </td></tr>
    <tr><td class="paramname">v1</td><td>double[] </td></tr>
    <tr><td class="paramname">v2</td><td>double[] </td></tr>
    <tr><td class="paramname">rslt</td><td>double[] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rslt has finite length, false if length(rslt) is zero. </dd></dl>

</div>
</div>
<a id="ac6436ceb5a8a2e58855e98eb592a7c88" name="ac6436ceb5a8a2e58855e98eb592a7c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6436ceb5a8a2e58855e98eb592a7c88">&#9670;&nbsp;</a></span>vectorTripleProductNorthPole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool geotess::GeoTessUtils::vectorTripleProductNorthPole </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized vector triple product (u x northPole) x u and store result in w. </p>
<p >Returns false is u is north or south pole.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>double[] </td></tr>
    <tr><td class="paramname">w</td><td>double[] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if w has finite length, false if length(w) is zero. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a70dede101812281603f492f3154757eb" name="a70dede101812281603f492f3154757eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dede101812281603f492f3154757eb">&#9670;&nbsp;</a></span>approximateLatitudes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geotess::GeoTessUtils::approximateLatitudes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, then an approximate algorithm will be used to convert back and forth between geocentric and geographic latitudes. </p>
<p >The approximation incurs an error of about 0.1 meters in latitude calculations but is faster than the correct calculation. </p>
<p >Note that the existence of this static, mutable variable technically violates thread-safety of this class. But given the assumption that the approximation is just as good as the true conversions, this is not a significant violation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="a00095_source.html">GeoTessUtils.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
